python_condition_errors = [
    {
        "slug": "the-kth-factor-of-n",
        "description": "You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.\nConsider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.",
        "examples": [
            "Input: n = 12, k = 3\nOutput: 3\nExplanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.",
            "Input: n = 7, k = 2\nOutput: 7\nExplanation: Factors list is [1, 7], the 2nd factor is 7.",
            "Input: n = 4, k = 4\nOutput: -1\nExplanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.",
        ],
        "constraints": "1 <= k <= n <= 1000",
        "release_time": 1692616031,
        "oracle_code": "class Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        j = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                num = i\n                j += 1\n            if j == k:\n                break\n        return num if j == k else -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to iterate through all positive integers from 1 to `n` and check if they are factors of `n`. The code aims to find the `kth` factor of `n`, where `k` is a given positive integer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code uses a simple iterative approach to find the `kth` factor of `n`. It initializes a variable `j` to keep track of the number of factors found. For each integer `i` from 1 to `n`, it checks if `i` is a factor of n by verifying if `n % i == 0`. If `i` is indeed a factor, it increments `j` and updates the variable `num` with the value of `i`.\\n\\n- The loop continues until `j` becomes equal to k or until all integers from 1 to n have been considered. If `j` becomes equal to `k`, it breaks out of the loop. At the end of the loop, if `j` is equal to `k`, it returns the value of `num`; otherwise, it returns `-1` to indicate that there is no `kth` factor.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthFactor(self, n: int, k: int) -> int:\\n        j = 0\\n        for i in range(1, n + 1):\\n            if n % i == 0:\\n                num = i\\n                j += 1\\n            if j == k:\\n                break\\n        return num if j == k else -1\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        j = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                num = i\n                j += 1\n            if j == k:\n                break\n        return num if j == k+1 else -1\n",
        "explanations": "\nThe bug is that 'j' should be compared to 'k', not 'k+1', leading to wrong results.\n",
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": 'Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in "14234" results in "12344".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.',
        "examples": [
            'Input: s = "84532", t = "34852"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n"84532" (from index 2 to 3) -> "84352"\n"84352" (from index 0 to 2) -> "34852"',
            'Input: s = "34521", t = "23415"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n"34521" -> "23451"\n"23451" -> "23415"',
            'Input: s = "12345", t = "12435"\nOutput: false',
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "release_time": 1690819672,
        "oracle_code": "class Solution:\n    def isTransformable(self, s: str, t: str) -> bool :\n        # make a mapping of deque lists called indexes \n        indexes = collections.defaultdict(collections.deque)\n        # enumerate s \n        for index, character in enumerate(s) :\n            # indexes at the int cast of character has this index added to it  \n            indexes[int(character)].append(index)\n\n        # get unique values in t \n        unique_t_values = set([int(t_i) for t_i in t])\n        # for t_v in unique t values \n        for t_v in unique_t_values : \n            # if not in indexes \n            if t_v not in indexes :\n                # return False as we are missing pieces  \n                return False \n        \n        # loop over t in order given  \n        for character in t : \n            # get the characters integer designation \n            character_designation = int(character)\n            # update may cause new misses which may prevent future searches \n            if character_designation not in indexes : \n                return False \n            # for index in range up to character designation \n            for lesser_character in range(character_designation) : \n                # if indexes at lesser character and indexes at lesser character lists 0th item is before indexes at character designations lists 0th item \n                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : \n                    # our lists are not transformable, False \n                    # this is because for any select string mapping of character designations that are greater than their sub indexes \n                    # it must be such that the index priors sub mapping does not interfere with the index current mapping. \n                    # this is detailed in the problem statement where they note that values must be in ascending order \n                    return False \n            # after consideration using this most recent index, remove it \n            indexes[character_designation].popleft()\n            # if length is now zero, remove it \n            if len(indexes[character_designation]) == 0 : \n                indexes.pop(character_designation)\n        \n        # if all characters able to sort, return it \n        return True",
        "content": "# Intuition\\nFaced with any substring sorting problems, I\\'m drawn to maps and graphs for ease of search space. As such, we can consider this one with not too much of a stretch of the mind. \\n\\nEach integer value in our selected string has a list of indices at which it appears. IF we make a mapping of these list of indices for each value in order of appearance in s, we can use that against the ordering of appearance of list of values in t (we do not necessarily need to make said list of t, but could if we so chose) \\n\\nOnce we have this map, our first bet is to actually get the set of unique items in t, which can be done rather nicely with generators that will do the autoskip inclusions as needed. \\n\\nUsing unique t, our first check is that all of the unique t values are present. If not, then we can skip to returning False. \\n\\nOtherwise, we need to loop over t, and for each character check if it is in our map. If not, also False. \\n\\nIf we then loop over values up to this point (such that if we drew say 5 we\\'d go from 0 to 4 inclusive) we need to find that the value is in indexes and that the indexes at that point has a starting value at least as advanced or more so than the indexes for the drawn values first appearance. If this does not occur, then they are not in ascending order and may also return False. \\n\\nIf all of that passes, we need to discard the current item at the front of indexes at the drawn character. If in doing so we now eliminate that list, we need to eliminate the character drawn from indices entirely (this is why we have that second check for inclusion near the top). \\n\\nIf we manage all of that, there\\'s nothing to stop the transformation and can return True. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse collections default dict with collections deque for each character valuation in s \\n\\nMake a map of the character values -> list of indices of occurrence in order from first to last \\n\\nMake a set of unique t values \\n\\n- For each unique t value in unique t values \\n    - if that value is not in our mapping \\n        - return False \\n\\nLoop over t (effectively getting the unique indices for each value of t) \\n- as you do, convert your character into its designated key (This is here for other mapping versions of the problem) \\n- if we do not have that designated ky in our map \\n    - return false \\n- otherwise, loop over lesser character designations in range to character designation \\n    - if we have the map at lesser character designation and the map at lesser character designation points to a list whose first index of occurrence is less than the first index of occurrence of our current character designation, it must be that they are not in order, and can return False \\n- after completing lesser character loop, remove the most recent occurrence of indexes at character designation by popping left from the map at the character designation \\n- if the map now points to an empty list for character designation, remove character designation from the map entirely.    \\n\\n# Complexity\\n- Time complexity : O(S + T)\\n    - O(S) to build s mapping \\n    - O(T) to build t unique characters \\n    - O(T) to loop over characters in T \\n        - within which we do at most O(5) work to loop in range of lesser characters on average \\n    - Total then is O(S + T + ~5T) -> O(S + C * T) -> O(S + T)  \\n\\n\\n- Space complexity : O(S + t) \\n    - Store O(s) lists of size to account for S, so O(S) \\n    - Store O(t) \\n    - Remove storage for potentially all of O(S) \\n    - Averages out to O(S + t) at worst  \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool :\\n        # make a mapping of deque lists called indexes \\n        indexes = collections.defaultdict(collections.deque)\\n        # enumerate s \\n        for index, character in enumerate(s) :\\n            # indexes at the int cast of character has this index added to it  \\n            indexes[int(character)].append(index)\\n\\n        # get unique values in t \\n        unique_t_values = set([int(t_i) for t_i in t])\\n        # for t_v in unique t values \\n        for t_v in unique_t_values : \\n            # if not in indexes \\n            if t_v not in indexes :\\n                # return False as we are missing pieces  \\n                return False \\n        \\n        # loop over t in order given  \\n        for character in t : \\n            # get the characters integer designation \\n            character_designation = int(character)\\n            # update may cause new misses which may prevent future searches \\n            if character_designation not in indexes : \\n                return False \\n            # for index in range up to character designation \\n            for lesser_character in range(character_designation) : \\n                # if indexes at lesser character and indexes at lesser character lists 0th item is before indexes at character designations lists 0th item \\n                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : \\n                    # our lists are not transformable, False \\n                    # this is because for any select string mapping of character designations that are greater than their sub indexes \\n                    # it must be such that the index priors sub mapping does not interfere with the index current mapping. \\n                    # this is detailed in the problem statement where they note that values must be in ascending order \\n                    return False \\n            # after consideration using this most recent index, remove it \\n            indexes[character_designation].popleft()\\n            # if length is now zero, remove it \\n            if len(indexes[character_designation]) == 0 : \\n                indexes.pop(character_designation)\\n        \\n        # if all characters able to sort, return it \\n        return True \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool :\n        indexes = collections.defaultdict(collections.deque)\n        for index, character in enumerate(s) :\n            indexes[int(character)].append(index)\n\n        unique_t_values = set([int(t_i) for t_i in t])\n        for t_v in unique_t_values : \n            if t_v not in indexes :\n                return False \n            \n        for character in t : \n            character_designation = int(character)\n            if character_designation not in indexes : \n                return False \n            for lesser_character in range(character_designation):\n                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : \n                    return False \n            indexes[character_designation].popleft()\n            if len(indexes[character_designation]) == 0 : \n                indexes.pop(character_designation)\n        \n        # if all characters able to sort, return it \n        return False\n",
        "explanations": "\nDespite the correct implementation, always returning False instead of True incorrectly signals non-transformability.\n",
    },
    {
        "slug": "restore-ip-addresses",
        "description": 'A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, "0.1.2.201" and "192.168.1.1" are valid IP addresses, but "0.011.255.245", "192.168.1.312" and "192.168@1.1" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.',
        "examples": [
            'Input: s = "25525511135"\nOutput: ["255.255.11.135","255.255.111.35"]',
            'Input: s = "0000"\nOutput: ["0.0.0.0"]',
            'Input: s = "101023"\nOutput: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]',
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "release_time": 1674285009,
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n",
        "explanations": "\nThe bug is: if len(cur)>4 or i>len(s), it should be if len(cur)>4 or i>=len(s)\n",
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = [].",
        ],
        "constraints": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "release_time": 1669639917,
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n\n        for k, v in winners.items(): \n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n",
        "explanations": "\nThe code wrongly loops through winners instead of losers to find single-lose players.\n",
    },
    {
        "slug": "invalid-transactions",
        "description": "A transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nYou are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\nReturn a list of transactions that are possibly invalid. You may return the answer in any order.",
        "examples": [
            'Input: transactions = ["alice,20,800,mtv","alice,50,100,beijing"]\nOutput: ["alice,20,800,mtv","alice,50,100,beijing"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.',
            'Input: transactions = ["alice,20,800,mtv","alice,50,1200,mtv"]\nOutput: ["alice,50,1200,mtv"]',
            'Input: transactions = ["alice,20,800,mtv","bob,50,1200,mtv"]\nOutput: ["bob,50,1200,mtv"]',
        ],
        "constraints": 'transactions.length <= 1000\nEach transactions[i] takes the form "{name},{time},{amount},{city}"\nEach {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of digits, and represent an integer between 0 and 1000.\nEach {amount} consist of digits, and represent an integer between 0 and 2000.',
        "release_time": 1667938900,
        "oracle_code": 'class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(",")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions)):\n            name, time, amount, city = transactions[trans].split(",")\n            if int(amount) > 1000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid',
        "content": '# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecords all transactions in a hashmap with default value as list, where the hashing key is the name of the transaction. Now in the second pass, it goes through each transaction and checks if amount is > 1000 else it searches all transactions with the same name in O(1) time and loops through it in O(n) time. If it finds a transaction with the conditions i.e. different city and absolute time difference <= 60. It will append it to the final list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\\n        invalid = []\\n        txn = collections.defaultdict(list)\\n        \\n        for trn in transactions:\\n            name, time, amount, city = trn.split(",")\\n            txn[name].append([time,amount,city])\\n        \\n        for trans in range(len(transactions)):\\n            name, time, amount, city = transactions[trans].split(",")\\n            if int(amount) > 1000:\\n                invalid.append(transactions[trans])\\n            else:\\n                for trn in txn[name]:\\n                    time_i, _, city_i = trn\\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\\n                        invalid.append(transactions[trans])\\n                        break\\n\\n        return invalid\\n```',
        "level": "medium",
        "buggy_code": '\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(",")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions)):\n            name, time, amount, city = transactions[trans].split(",")\n            if int(amount) > 10000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid\n',
        "explanations": "\nI made condition int(amount) > 10000 instead of 1000 which fails the 1000 condition.\n",
    },
    {
        "slug": "binary-search",
        "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4",
            "Input: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1",
        ],
        "constraints": "1 <= nums.length <= 104\n-104 < nums[i], target < 104\nAll the integers in nums are unique.\nnums is sorted in ascending order.",
        "release_time": 1680309400,
        "oracle_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if target not in nums:\n            return -1\n        \n        left, right = 0, len(nums)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            return -1\\n        \\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left\\n        \\n```\\nOne-liner in python:\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        return bisect_left(nums, target) if target in nums else -1\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if target not in nums:\n            return -1\n        \n        left, right = 0, len(nums)\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left\n",
        "explanations": "\nThe condition in the while loop will result in an index out of bounds exception.\n",
    },
    {
        "slug": "sliding-puzzle",
        "description": "On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.\nThe state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\nGiven the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.",
        "examples": [
            "Input: board = [[1,2,3],[4,0,5]]\nOutput: 1\nExplanation: Swap the 0 and the 5 in one move.",
            "Input: board = [[1,2,3],[5,4,0]]\nOutput: -1\nExplanation: No number of moves will make the board solved.",
            "Input: board = [[4,1,2],[5,0,3]]\nOutput: 5\nExplanation: 5 is the smallest number of moves that solves the board.\nAn example path:\nAfter move 0: [[4,1,2],[5,0,3]]\nAfter move 1: [[4,1,2],[0,5,3]]\nAfter move 2: [[0,1,2],[4,5,3]]\nAfter move 3: [[1,0,2],[4,5,3]]\nAfter move 4: [[1,2,0],[4,5,3]]\nAfter move 5: [[1,2,3],[4,5,0]]",
        ],
        "constraints": "board.length == 2\nboard[i].length == 3\n0 <= board[i][j] <= 5\nEach value board[i][j] is unique.",
        "release_time": 1673813066,
        "oracle_code": "class Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        def get_neighbors(board):\n            neighbors = []\n            r, c = 0, 0\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        r, c = i, j\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                new_r, new_c = r + i, c + j\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\n                    new_board = [row[:] for row in board]\n                    new_board[r][c] = new_board[new_r][new_c]\n                    new_board[new_r][new_c] = 0\n                    neighbors.append(new_board)\n            return neighbors\n\n        queue = deque()\n        queue.append((board, 0))\n        seen = set()\n        seen.add(tuple(tuple(row) for row in board))\n\n        while queue:\n            board, moves = queue.popleft()\n            if board == [[1, 2, 3], [4, 5, 0]]:\n                return moves\n            for neighbor in get_neighbors(board):\n                if tuple(tuple(row) for row in neighbor) not in seen:\n                    queue.append((neighbor, moves + 1))\n                    seen.add(tuple(tuple(row) for row in neighbor))\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is that this problem can be solved using a breadth-first search (BFS) algorithm, where we start with the initial board state and explore all possible moves (by swapping the empty space with its neighboring tiles) until we reach the desired board state.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use a BFS algorithm to explore all possible moves from the initial board state. The function starts by initializing a queue and adding the initial board state and the number of moves (0) to the queue. It also initializes a set to keep track of the board states that have already been seen. The function then enters a while loop that continues until the queue is empty. In each iteration, the function takes the first board state and move count from the queue, and checks if the board state is the desired state. If it is, the function returns the number of moves. If not, the function uses a helper function get_neighbors to find all possible moves (by swapping the empty space with its neighboring tiles) and adds them to the queue. The function also adds the new board states to the set of seen states. If the queue becomes empty, the function returns -1 indicating that the desired board state was not reached.\\n\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\\n        def get_neighbors(board):\\n            neighbors = []\\n            r, c = 0, 0\\n            for i in range(2):\\n                for j in range(3):\\n                    if board[i][j] == 0:\\n                        r, c = i, j\\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                new_r, new_c = r + i, c + j\\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\\n                    new_board = [row[:] for row in board]\\n                    new_board[r][c] = new_board[new_r][new_c]\\n                    new_board[new_r][new_c] = 0\\n                    neighbors.append(new_board)\\n            return neighbors\\n\\n        queue = deque()\\n        queue.append((board, 0))\\n        seen = set()\\n        seen.add(tuple(tuple(row) for row in board))\\n\\n        while queue:\\n            board, moves = queue.popleft()\\n            if board == [[1, 2, 3], [4, 5, 0]]:\\n                return moves\\n            for neighbor in get_neighbors(board):\\n                if tuple(tuple(row) for row in neighbor) not in seen:\\n                    queue.append((neighbor, moves + 1))\\n                    seen.add(tuple(tuple(row) for row in neighbor))\\n        return -1\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        def get_neighbors(board):\n            neighbors = []\n            r, c = 0, 0\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        r, c = i, j\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                new_r, new_c = r + i, c + j\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\n                    new_board = [row[:] for row in board]\n                    new_board[r][c] = new_board[new_r][new_c]\n                    new_board[new_r][new_c] = 0\n                    neighbors.append(new_board)\n            return neighbors\n\n        queue = deque()\n        queue.append((board, 0))\n        seen = set()\n        seen.add(tuple(tuple(row) for row in board))\n\n        while queue:\n            board, moves = queue.popleft()\n            if board == [[1, 2, 3], [5, 4, 0]]:      \n                return moves\n            for neighbor in get_neighbors(board):\n                if tuple(tuple(row) for row in neighbor) not in seen:\n                    queue.append((neighbor, moves + 1))\n                    seen.add(tuple(tuple(row) for row in neighbor))\n        return -1\n",
        "explanations": "\nThe board state to check for the solution is incorrect. The final state is [[1, 2, 3], [4, 5, 0]], not [[1, 2, 3], [5, 4, 0]].\n",
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4",
        ],
        "constraints": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
        "release_time": 1679245385,
        "oracle_code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n            if count == 2:\n                return True\n        return False\n",
        "explanations": "\nWe shouldn't return True until we traverse all elements of the array.\n",
    },
    {
        "slug": "palindrome-pairs",
        "description": "You are given a 0-indexed array of unique strings words.\nA palindrome pair is a pair of integers (i, j) such that:\n\n0 <= i, j < words.length,\ni != j, and\nwords[i] + words[j] (the concatenation of the two strings) is a palindrome.\n\nReturn an array of all the palindrome pairs of words.",
        "examples": [
            'Input: words = ["abcd","dcba","lls","s","sssll"]\nOutput: [[0,1],[1,0],[3,2],[2,4]]\nExplanation: The palindromes are ["abcddcba","dcbaabcd","slls","llssssll"]',
            'Input: words = ["bat","tab","cat"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are ["battab","tabbat"]',
            'Input: words = ["a",""]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are ["a","a"]',
        ],
        "constraints": "1 <= words.length <= 5000\n0 <= words[i].length <= 300\nwords[i] consists of lowercase English letters.",
        "release_time": 1663377683,
        "oracle_code": 'class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != "" and "" in backward and word == word[::-1]:\n                res.append([i, backward[""]])\n                res.append([backward[""], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res',
        "content": 'Please upvote if it helps!\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}, []\\n        for i, word in enumerate(words):\\n            backward[word[::-1]] = i\\n\\n        for i, word in enumerate(words):\\n            \\n            if word in backward and backward[word] != i:\\n                res.append([i, backward[word]])\\n                \\n            if word != "" and "" in backward and word == word[::-1]:\\n                res.append([i, backward[""]])\\n                res.append([backward[""], i])\\n                \\n            for j in range(len(word)):\\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\\n                    res.append([backward[word[j:]], i])\\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\\n                    res.append([i, backward[word[:j]]])\\n                    \\n        return res',
        "level": "hard",
        "buggy_code": '\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != "" and "" in backward and word == word[::-1]:\n                res.append([i, backward[""]])\n                res.append([backward[""], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res\n',
        "explanations": "\nIn the first check inside the for loop, the slicing indices are incorrectly used for reversing the substring which results in incorrect palindrome checks.\n",
    },
    {
        "slug": "minimum-bit-flips-to-convert-number",
        "description": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\nFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.",
        "examples": [
            "Input: start = 10, goal = 7\nOutput: 3\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 1010 -> 1011.\n- Flip the third bit from the right: 1011 -> 1111.\n- Flip the fourth bit from the right: 1111 -> 0111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.",
            "Input: start = 3, goal = 4\nOutput: 3\nExplanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 011 -> 010.\n- Flip the second bit from the right: 010 -> 000.\n- Flip the third bit from the right: 000 -> 100.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.",
        ],
        "constraints": "0 <= start, goal <= 109",
        "release_time": 1677410468,
        "oracle_code": "class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(50):\n            if s[i]!=g[i]:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(51):\n            if s[i]!=g[i]:\n                count+=1\n        return count\n",
        "explanations": "\nThe loop is iterating 51 times instead of 50, which will cause an index error.\n",
    },
    {
        "slug": "maximum-profit-of-operating-a-centennial-wheel",
        "description": "You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.\nYou are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\nYou can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\nReturn the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.",
        "examples": [
            "Input: customers = [8,3], boardingCost = 5, runningCost = 6\nOutput: 3\nExplanation: The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times.",
            "Input: customers = [10,9,6], boardingCost = 6, runningCost = 4\nOutput: 7\nExplanation:\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.",
            "Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\nOutput: -1\nExplanation:\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1.",
        ],
        "constraints": "n == customers.length\n1 <= n <= 105\n0 <= customers[i] <= 50\n1 <= boardingCost, runningCost <= 100",
        "release_time": 1687863850,
        "oracle_code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit=-1\n        ans=i=curRounds=curCustomers=rem=0\n        while i<len(customers) or rem:\n            if i<len(customers):\n                rem+=customers[i]\n                i+=1\n            curRounds+=1\n            if rem-4>=0:\n                rem-=4\n                curCustomers+=4\n            else:\n                curCustomers+=rem\n                rem=0\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\n            if curProfit>maxProfit:\n                maxProfit=curProfit\n                ans=curRounds\n        return -1 if maxProfit<=0 else ans",
        "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxProfit=-1\\n        ans=i=curRounds=curCustomers=rem=0\\n        while i<len(customers) or rem:\\n            if i<len(customers):\\n                rem+=customers[i]\\n                i+=1\\n            curRounds+=1\\n            if rem-4>=0:\\n                rem-=4\\n                curCustomers+=4\\n            else:\\n                curCustomers+=rem\\n                rem=0\\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\\n            if curProfit>maxProfit:\\n                maxProfit=curProfit\\n                ans=curRounds\\n        return -1 if maxProfit<=0 else ans\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit=-1\n        ans=i=curRounds=curCustomers=rem=0\n        while i<len(customers) or rem:\n            if i<len(customers):\n                rem+=customers[i]\n                i+=1\n            curRounds+=1\n            if rem-4>=0:\n                rem-=4\n                curCustomers+=4\n            else:\n                curCustomers+=rem\n                rem=0\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\n            if curProfit>=maxProfit:\n                maxProfit=curProfit\n                ans=curRounds\n        return -1 if maxProfit<=0 else ans\n",
        "explanations": '\nChanged the if condition from "curProfit > maxProfit" to "curProfit >= maxProfit" which will result in returning the latest possible round when profits are the same instead of the earliest.\n',
    },
    {
        "slug": "make-array-zero-by-subtracting-equal-amounts",
        "description": "You are given a non-negative integer array nums. In one operation, you must:\n\nChoose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.\nSubtract x from every positive element in nums.\n\nReturn the minimum number of operations to make every element in nums equal to 0.",
        "examples": [
            "Input: nums = [1,5,0,3,5]\nOutput: 3\nExplanation:\nIn the first operation, choose x = 1. Now, nums = [0,4,0,2,4].\nIn the second operation, choose x = 2. Now, nums = [0,2,0,0,2].\nIn the third operation, choose x = 2. Now, nums = [0,0,0,0,0].",
            "Input: nums = [0]\nOutput: 0\nExplanation: Each element in nums is already 0 so no operations are needed.",
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 100",
        "release_time": 1679755806,
        "oracle_code": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num == 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniq_non_zero)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA brute-force approach will be:\\n1. sort in increasing order\\n2. get first non-zero element\\n3. deduct all non-zero elements with the above\\n4. continue until all non-zero elements are zeroed out\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe above intuition, leads to the following realization:\\n\\nIf we count unique non-zero elements in the array, that many\\nnumber of operations are required to zero out the entire array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where is n is the length of the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m) where m is the total number of unique non-zero elements in the array\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        uniq_non_zero = set()\\n        for num in nums:\\n            if num == 0:\\n                continue\\n            uniq_non_zero.add(num)\\n        return len(uniq_non_zero)\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num != 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniq_non_zero)\n",
        "explanations": "\nThe function will add only zeros to the set, rather than non-zero values.\n",
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.",
        ],
        "constraints": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "release_time": 1691487651,
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        out=[]\n        for i in range(0,len(nums1)):\n            if(nums2.index(nums1[i])==len(nums2)-1):\n                out.append(-1)\n            else:\n                j=nums2.index(nums1[i])+1\n                while(1):\n                    if(nums1[i]<nums2[j]):\n                        out.append(nums2[j])\n                        break\n                    if(j==len(nums2)-1):\n                        out.append(-1)\n                        break\n                    j+=1\n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        out=[]\\n        for i in range(0,len(nums1)):\\n            if(nums2.index(nums1[i])==len(nums2)-1):\\n                out.append(-1)\\n            else:\\n                j=nums2.index(nums1[i])+1\\n                while(1):\\n                    if(nums1[i]<nums2[j]):\\n                        out.append(nums2[j])\\n                        break\\n                    if(j==len(nums2)-1):\\n                        out.append(-1)\\n                        break\\n                    j+=1\\n        return out\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        out=[]\n        for i in range(0,len(nums1)):\n            if(nums2.index(nums1[i])==len(nums2)-1):\n                out.append(-1)\n            else:\n                j=nums2.index(nums1[i])+1\n                while(1):\n                    if(nums1[i]<nums2[j]):\n                        out.append(nums2[j])\n                        break\n                    if(j==len(nums2)):\n                        out.append(-1)\n                        break\n                    j+=1\n        return out\n",
        "explanations": "\nThe while loop will attempt to index the nums2 list out of its range.\n",
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []",
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "release_time": 1666016205,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                q.append(curr.left)\n                q.append(curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n",
        "explanations": "\nThe bug is caused by appending current node's children to the queue without checking if they exist.\n",
    },
    {
        "slug": "make-k-subarray-sums-equal",
        "description": "You are given a 0-indexed integer array arr and an integer k. The array arr is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.\nYou can do the following operation any number of times:\n\nPick any element from arr and increase or decrease it by 1.\n\nReturn the minimum number of operations such that the sum of each subarray of length k is equal.\nA subarray is a contiguous part of the array.",
        "examples": [
            "Input: arr = [1,4,1,3], k = 2\nOutput: 1\nExplanation: we can do one operation on index 1 to make its value equal to 3.\nThe array after the operation is [1,3,1,3]\n- Subarray starts at index 0 is [1, 3], and its sum is 4 \n- Subarray starts at index 1 is [3, 1], and its sum is 4 \n- Subarray starts at index 2 is [1, 3], and its sum is 4 \n- Subarray starts at index 3 is [3, 1], and its sum is 4",
            "Input: arr = [2,5,5,7], k = 3\nOutput: 5\nExplanation: we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5.\nThe array after the operations is [5,5,5,5]\n- Subarray starts at index 0 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 1 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 2 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 3 is [5, 5, 5], and its sum is 15",
        ],
        "constraints": "1 <= k <= arr.length <= 105\n1 <= arr[i] <= 109",
        "release_time": 1680365297,
        "oracle_code": "class Solution:\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\n        lA = len(A)\n        g = gcd(lA, K)\n        retV = 0\n        for i in range(g):\n            med = int(median(A[i::g]))\n            retV += sum(abs(a-med) for a in A[i::g])\n            \n        return retV",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\\n        lA = len(A)\\n        g = gcd(lA, K)\\n        retV = 0\\n        for i in range(g):\\n            med = int(median(A[i::g]))\\n            retV += sum(abs(a-med) for a in A[i::g])\\n            \\n        return retV            \\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\n        lA = len(A)\n        g = gcd(lA, K)\n        retV = 0\n        for i in range(g):\n            med = int(median(A[i:g]))\n            retV += sum(abs(a-med) for a in A[i:g])\n            \n        return retV\n",
        "explanations": "\nThe array slicing in the loop with A[i:g] will not execute for every gth element after i but only for the ones in the range from i to g. \n",
    },
    {
        "slug": "node-with-highest-edge-score",
        "description": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.",
        "examples": [
            "Input: edges = [1,0,0,0,0,7,7,5]\nOutput: 7\nExplanation:\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.",
            "Input: edges = [2,0,0,2]\nOutput: 0\nExplanation:\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0.",
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
        "release_time": 1673006370,
        "oracle_code": "class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray Traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx and i != n-1: \n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans\n",
        "explanations": "\nThe logic error is that the maximum score can't be updated at last iteration.\n",
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "description": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.",
        "examples": [
            "Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\nOutput: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.",
            "Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from (0, 0) to (2, 2).",
            "Input: grid = [[1,2],[4,3]]\nOutput: 1",
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n1 <= grid[i][j] <= 4",
        "release_time": 1673811505,
        "oracle_code": "class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\n        M, N = range(m), range(n)\n\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\n\n        def dfs(x: int,y: int)->None:\n            while not seen(x,y):\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\n                queue.append((x,y))\n                x,y = x+dx, y+dy\n            return\n\n        dfs(0, 0)\n\n        while queue:\n            if (m-1, n-1) in queue: return cost\n            cost += 1\n            q = len(queue)\n\n            for _ in range(q):\n                x, y = queue.popleft()\n                for dx,dy in dir[1:]:\n                    dfs(x+dx, y+dy)",
        "content": "We re-use grid to keep track of `seen`.\\n```\\nclass Solution:\\n    def minCost(self, grid: List[List[int]]) -> int:\\n\\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\\n        M, N = range(m), range(n)\\n\\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\\n\\n        def dfs(x: int,y: int)->None:\\n            while not seen(x,y):\\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\\n                queue.append((x,y))\\n                x,y = x+dx, y+dy\\n            return\\n\\n        dfs(0, 0)\\n\\n        while queue:\\n            if (m-1, n-1) in queue: return cost\\n            cost += 1\\n            q = len(queue)\\n\\n            for _ in range(q):\\n                x, y = queue.popleft()\\n                for dx,dy in dir[1:]:\\n                    dfs(x+dx, y+dy)\\n```\\n[https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/submissions/878791604/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is worstcase\\n *O*(*MN*).",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\n        M, N = range(m), range(n)\n\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\n\n        def dfs(x: int,y: int)->None:\n            while not seen(x,y):\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\n                queue.append((x,y))\n                x,y = x+dx, y+dy\n            return\n\n        dfs(0, 0)\n        cost += 1\n\n        while queue:\n            if (m-1, n-1) in queue: return cost\n            cost +=1 \n            q = len(queue)\n\n            for _ in range(q):\n                x, y = queue.popleft()\n                for dx,dy in dir[1:]:\n                    dfs(x+dx, y+dy)\n",
        "explanations": "\nThe first cost increment should be part of the while loop, incorrect placement results in error.\n",
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.",
        ],
        "constraints": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "release_time": 1687022285,
        "oracle_code": 'class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float("inf")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)',
        "content": '# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float("inf")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```',
        "level": "medium",
        "buggy_code": '\nclass Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float("inf")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[1],grid[0]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n',
        "explanations": "\nThe bug is that the for-loop iterates over the wrong rows resulting in math errors.\n",
    },
    {
        "slug": "check-if-point-is-reachable",
        "description": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\n\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.",
        "examples": [
            "Input: targetX = 6, targetY = 9\nOutput: false\nExplanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.",
            "Input: targetX = 4, targetY = 7\nOutput: true\nExplanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7).",
        ],
        "constraints": "1 <= targetX, targetY\u00a0<= 109",
        "release_time": 1674321554,
        "oracle_code": "class Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        def gcd(a, b):\n            while b:\n                a, b=b, a%b\n            return a\n        d=gcd(targetX, targetY)\n        while d!=1:\n            if d&1:\n                return False\n            d>>=1\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is quite straightforward: a pair (a, b) is accessible if and only if the greatest common divisor of a and b, gcd(a, b), is a power of 2.\\nThe difficulty is proving this, which fortunately was not required during the contest. Anyway, here is the proof.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn one direction, note that all four operations preserve this property. The starting pair (1, 1) has it since $gcd(1, 1)=1=2^0$, the first two operations preserve the gcd, and the last two operations can multiply the gcd by 2 (or not). Thus, gcd(a, b) can only be a power of 2.\\n\\nConversely, starting from (1, 1) and multiplying the first term repeatedly by 2 we can obtain any pair of the form $(2^n, 1)$, then subtracting $1$ from $2^n$ repeatedly we can obtain any pair of the form $(n, 1)$.\\n\\nMultiplying the second term by 2 repeatedly we can obtain any pair of the form $(n, 2^m)$, then by subtracting $n$ from $2^m$ repeatedly we can obtain any pair of the form $(n,\\\\ 2^m \\\\mod n)$.\\n\\nSuppose we want to obtain the pair (n, k), where k<n and gcd(n, k)=1. Consider the infinite arithmetic progression (n, n+k, n+2k, ...). By Dirichlet\\'s theorem, this progression contains infinitely many primes. Consider one of them: p=n+jk for some $j \\\\geq 0$.\\n\\nBy a slight generalization of [Artin\\'s conjecture](https://mathworld.wolfram.com/ArtinsConjecture.html) (the generalization may need proof, but Artin\\'s conjecture was proved by Christopher Hooley, [\"On Artin\\'s Conjecture\"](https://eudml.org/doc/150785), in 1967, assuming the [Generalized Riemann Hypothesis](https://en.wikipedia.org/wiki/Generalized_Riemann_hypothesis)), there are infinitely many such p for which 2 is a primitive root of unity modulo p, meaning that $2^{p-1} \\\\equiv 1 \\\\mod p$ and $2^{k} \\\\not \\\\equiv 1 \\\\mod p$ for $0<k<p-1$.\\n\\nWe know we can obtain any pair of the form $(p,\\\\ 2^m \\\\mod p)$. Since p is prime, the multiplicative group $\\\\mathbb Z_p^*$ is cyclic. Since 2 is a generator (its order is equal to the order of the group), we can obtain any pair (p, k) where $1 \\\\leq k <p$ using powers of 2 modulo p, including the k we want.\\n\\nBut this is the same as (n+jk, k) and then by repeatedly subtracting k from n+jk we can obtain (n, k), as desired.\\n\\nBy symmetry (doing the same thing in reverse if necessary), we can obtain any pair (n, m) where gcd(m, n)=1. Finally, multiplying m and n by (possibly different) arbitrary powers of 2 we can obtain any pair whose gcd is a power of two.\\n\\nEdited: The initial proof was wrong and I corrected it.\\n\\n# Complexity\\n- Time complexity: Logarithmic: $O(\\\\max(\\\\log a, \\\\log b))$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        def gcd(a, b):\\n            while b:\\n                a, b=b, a%b\\n            return a\\n        d=gcd(targetX, targetY)\\n        while d!=1:\\n            if d&1:\\n                return False\\n            d>>=1\\n        return True\\n        \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        def gcd(a, b):\n            while b:\n                a, b=b, a%b\n            return a\n        d=gcd(targetX, targetY)\n        while d!=0:\n            if d&1:\n                return False\n            d>>=1\n        return True\n",
        "explanations": "\nThe loop never ends if gcd of targetX and targetY don't reduce to 1. \n",
    },
    {
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "description": "Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.",
        "examples": [
            "Input: nums = [1,3,6,10,12,15]\nOutput: 9\nExplanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.",
            "Input: nums = [1,2,4,7,10]\nOutput: 0\nExplanation: There is no single number that satisfies the requirement, so return 0.",
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i] <= 1000",
        "release_time": 1676326760,
        "oracle_code": "class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0",
        "content": "# Intuition\\nI wanted to solve this problem in **one line** using python, I figured this was the perfect use for the **Walrus Operator!**\\n\\n# Approach\\nI didn\\'t want any extra iterations, so we perform a list comprehention with only the values divisible by 6 (2 and 3) and use the walrus operator to store the comprehention in *lst*. Then, we can take the average as you would expect, accounting for dividing by zero using an in-line if statement.  \\n\\nIf you\\'ve never used the walrus operator before: https://realpython.com/python-walrus-operator/ \\n\\n# Complexity\\n- Time complexity:\\nO(n), we iterate over each item in the input list once. \\n\\n- Space complexity:\\nO(n), we store all elements divisible by both 2 and 3.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def averageValue(self, nums: List[int]) -> int:\\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0 \\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 1 else 0\n",
        "explanations": "\nThe bug lies in the condition of the if statement, which won't calculate the average for a single number.\n",
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "description": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.",
        "examples": [
            "Input: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.",
            "Input: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10.",
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
        "release_time": 1670732887,
        "oracle_code": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop())\n            res += ans\n            \n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n+1):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop())\n            res += ans\n            \n        return res\n",
        "explanations": '\nThe bug is in the second for-loop where "n+1" causes pop from an empty list.\n',
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2.",
        ],
        "constraints": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "release_time": 1678177862,
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return False\n        return True\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right\n",
        "explanations": "\nSwapped boolean return values in satisfiesTrip causing function to return incorrect results.\n",
    },
    {
        "slug": "minimum-speed-to-arrive-on-time",
        "description": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\nEach train can only depart at an integer hour, so you may need to wait in between each train ride.\n\nFor example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\n\nReturn the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\nTests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.",
        "examples": [
            "Input: dist = [1,3,2], hour = 6\nOutput: 1\nExplanation: At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark.",
            "Input: dist = [1,3,2], hour = 2.7\nOutput: 3\nExplanation: At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark.",
            "Input: dist = [1,3,2], hour = 1.9\nOutput: -1\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.",
        ],
        "constraints": "n == dist.length\n1 <= n <= 105\n1 <= dist[i] <= 105\n1 <= hour <= 109\nThere will be at most two digits after the decimal point in hour.",
        "release_time": 1690342800,
        "oracle_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour + 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left",
        "content": "![image.png](https://assets.leetcode.com/users/images/b88e2aad-dabb-4eac-afd0-759a7cc70942_1690342594.5715153.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour - 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left\n",
        "explanations": '\nComparison condition in if statement is wrong. Should be "if len(dist) > hour", not "if len(dist) >= hour - 1".\n',
    },
    {
        "slug": "count-the-repetitions",
        "description": 'We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == ["abc", 3] =="abcabcabc".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = "abc" can be obtained from s2 = "abdbec" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.',
        "examples": [
            'Input: s1 = "acb", n1 = 4, s2 = "ab", n2 = 2\nOutput: 2',
            'Input: s1 = "acb", n1 = 1, s2 = "acb", n2 = 1\nOutput: 1',
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "release_time": 1671908671,
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n",
        "explanations": "\nComparing rec[-1] with n1 this upfront may lead to premature termination of the procedure.\n",
    },
    {
        "slug": "fizz-buzz",
        "description": 'Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == "FizzBuzz" if i is divisible by 3 and 5.\nanswer[i] == "Fizz" if i is divisible by 3.\nanswer[i] == "Buzz" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.',
        "examples": [
            'Input: n = 3\nOutput: ["1","2","Fizz"]',
            'Input: n = 5\nOutput: ["1","2","Fizz","4","Buzz"]',
            'Input: n = 15\nOutput: ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]',
        ],
        "constraints": "1 <= n <= 104",
        "release_time": 1691389137,
        "oracle_code": 'class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3==0 and  i % 5==0 :\n                arr.append("FizzBuzz")\n            elif i % 3==0:\n                arr.append("Fizz")\n            elif i % 5==0 :\n                arr.append("Buzz")\n  \n            else:\n                arr.append(str(i))\n        return(arr)',
        "content": '# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i % 3==0 and  i % 5==0 :\\n                arr.append("FizzBuzz")\\n            elif i % 3==0:\\n                arr.append("Fizz")\\n            elif i % 5==0 :\\n                arr.append("Buzz")\\n  \\n            else:\\n                arr.append(str(i))\\n        return(arr)\\n```',
        "level": "easy",
        "buggy_code": '\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(0,n+1):\n            if i % 3==0 and  i % 5==0 :\n                arr.append("FizzBuzz")\n            elif i % 3==0:\n                arr.append("Fizz")\n            elif i % 5==0 :\n                arr.append("Buzz")\n  \n            else:\n                arr.append(str(i))\n        return(arr)\n',
        "explanations": "\nRange starts from 0 instead of 1, causing incorrect FizzBuzz results and inclusion of 0.\n",
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].",
        ],
        "constraints": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "release_time": 1692505877,
        "oracle_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i=int(s)+1\n        li=list(map(int,str(i)))  \n        return li",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i=int(s)+1\n        if i<10:\n            li=[]\n        else:\n            li=list(map(int,str(i)))  \n        return li\n",
        "explanations": "\nSpecifically, the bug handles all cases where number is less than 10 incorrectly by returning an empty list.\n",
    },
    {
        "slug": "number-of-ways-to-split-array",
        "description": "You are given a 0-indexed integer array nums of length n.\nnums contains a valid split at index i if the following are true:\n\nThe sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.\nThere is at least one element to the right of i. That is, 0 <= i < n - 1.\n\nReturn the number of valid splits in nums.",
        "examples": [
            "Input: nums = [10,4,-8,7]\nOutput: 2\nExplanation: \nThere are three ways of splitting nums into two non-empty parts:\n- Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split.\n- Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, i = 1 is a valid split.\n- Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split.\nThus, the number of valid splits in nums is 2.",
            "Input: nums = [2,3,1,0]\nOutput: 2\nExplanation: \nThere are two valid splits in nums:\n- Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split. \n- Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split.",
        ],
        "constraints": "2 <= nums.length <= 105\n-105 <= nums[i] <= 105",
        "release_time": 1687160167,
        "oracle_code": "class Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        cnt=0\n        left=nums[0]\n        right=sum(nums[1:])\n        if left>=right:\n            cnt+=1\n        for i in range(1,len(nums)-1):\n            left+=nums[i]\n            right-=nums[i]\n            if left>=right:\n                cnt+=1\n        return cnt",
        "content": "# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        cnt=0\\n        left=nums[0]\\n        right=sum(nums[1:])\\n        if left>=right:\\n            cnt+=1\\n        for i in range(1,len(nums)-1):\\n            left+=nums[i]\\n            right-=nums[i]\\n            if left>=right:\\n                cnt+=1\\n        return cnt\\n\\n```\\n\\n***Please Upvote***",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        cnt=0\n        left=nums[0]\n        right=sum(nums[0:])\n        if left>=right:\n            cnt+=1\n        for i in range(1,len(nums)-1):\n            left+=nums[i]\n            right-=nums[i]\n            if left>=right:\n                cnt+=1\n        return cnt\n",
        "explanations": "\nThe right sum is incorrectly including the first number, causing incorrectly counting splits.\n",
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "release_time": 1691087840,
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1\n",
        "explanations": "\nThe bug is in the if condition where the index p1-2 is used which can be negative.\n",
    },
    {
        "slug": "frog-position-after-t-seconds",
        "description": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666.",
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1.",
        ],
        "constraints": "1 <= n <= 100\nedges.length == n - 1\nedges[i].length == 2\n1 <= ai, bi <= n\n1 <= t <= 50\n1 <= target <= n",
        "release_time": 1687584099,
        "oracle_code": "from queue import Queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if edges == []:\n            if target == 1:return 1\n            return 0\n\n        d = {}\n        for i in edges:\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\n        \n        visit = [0]*(n+1)\n\n        q = Queue()     \n        q.put([1 , 1])\n\n        for dur in range(t):\n            \n            l = q.qsize()\n            for i in range(l):\n                temp = q.get()\n\n                # Count no.of non-visited nodes\n                count = 0\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: count += 1\n            \n                if temp[0] == target and count == 0:     \n                    # If the target is reached and if its the end node\n                    return temp[1]\n                \n                if visit[temp[0]] != 0:    # if already visited\n                    continue\n                \n                visit[temp[0]] = 1\n\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n                \n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n            if temp[0] == target:\n                return temp[1]\n\n        return 0",
        "content": "\\n# Code\\n```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if edges == []:\\n            if target == 1:return 1\\n            return 0\\n\\n        d = {}\\n        for i in edges:\\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\\n        \\n        visit = [0]*(n+1)\\n\\n        q = Queue()     \\n        q.put([1 , 1])\\n\\n        for dur in range(t):\\n            \\n            l = q.qsize()\\n            for i in range(l):\\n                temp = q.get()\\n\\n                # Count no.of non-visited nodes\\n                count = 0\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: count += 1\\n            \\n                if temp[0] == target and count == 0:     \\n                    # If the target is reached and if its the end node\\n                    return temp[1]\\n                \\n                if visit[temp[0]] != 0:    # if already visited\\n                    continue\\n                \\n                visit[temp[0]] = 1\\n\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\\n                \\n        \\n        l = q.qsize()\\n        for i in range(l):\\n            temp = q.get()\\n            if temp[0] == target:\\n                return temp[1]\\n\\n        return 0\\n```",
        "level": "hard",
        "buggy_code": "\nfrom queue import Queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if edges == []:\n            if target == 1:return 1\n            return 0\n\n        d = {}\n        for i in edges:\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\n        \n        visit = [0]*(n+1)\n\n        q = Queue()     \n        q.put([1 , 1])\n\n        for dur in range(t+1):\n            \n            l = q.qsize()\n            for i in range(l):\n                temp = q.get()\n\n                # Count no.of non-visited nodes\n                count = 0\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: count += 1\n            \n                if temp[0] == target and count == 0:     \n                    # If the target is reached and if its the end node\n                    return temp[1]\n                \n                if visit[temp[0]] != 0:    # if already visited\n                    continue\n                \n                visit[temp[0]] = 1\n\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n                \n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n            if temp[0] == target:\n                return temp[1]\n\n        return 0\n",
        "explanations": "\nThe loop 'for dur in range(t+1):' is running for 't+1' iterations instead of 't'.\n",
    },
    {
        "slug": "minimum-difference-between-highest-and-lowest-of-k-scores",
        "description": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\nPick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\nReturn the minimum possible difference.",
        "examples": [
            "Input: nums = [90], k = 1\nOutput: 0\nExplanation: There is one way to pick score(s) of one student:\n- [90]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.",
            "Input: nums = [9,4,1,7], k = 2\nOutput: 2\nExplanation: There are six ways to pick score(s) of two students:\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2.",
        ],
        "constraints": "1 <= k <= nums.length <= 1000\n0 <= nums[i] <= 105",
        "release_time": 1664874410,
        "oracle_code": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        res = 100000\n        \n        for i in range(len(nums) - k + 1):\n            arr = nums[i:i + k]\n            res = min(res, arr[-1] - arr[0])\n            \n        return res",
        "content": "**Solution 1:**\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res = 100000\\n        \\n        for i in range(len(nums) - k + 1):\\n            arr = nums[i:i + k]\\n            res = min(res, arr[-1] - arr[0])\\n            \\n        return res\\n```\\n\\n**Solution 2:**\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        arr = nums[:k]\\n        res = arr[-1] - arr[0]\\n        \\n        for i in range(k, len(nums)):\\n            arr.pop(0)\\n            arr.append(nums[i])\\n            res = min(res, arr[-1] - arr[0])\\n            \\n        return res\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        res = 100000\n        \n        for i in range(len(nums) - k):\n            arr = nums[i:i + k]\n            res = min(res, arr[-1] - arr[0])\n            \n        return res\n",
        "explanations": "\nThe range in the for loop should end at len(nums)-k+1, not len(nums)-k.\n",
    },
    {
        "slug": "valid-parenthesis-string",
        "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
        "examples": [
            'Input: s = "()"\nOutput: true',
            'Input: s = "(*)"\nOutput: true',
            'Input: s = "(*))"\nOutput: true',
        ],
        "constraints": "1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
        "release_time": 1674151600,
        "oracle_code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1] > sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n",
        "explanations": "\nThe bug occurs as the program inappropriately pop st and sr when st[-1] is greater than sr[-1].\n",
    },
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.",
        "examples": [
            "Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.",
            "Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.",
            "Input: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1.",
        ],
        "constraints": "n == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n",
        "release_time": 1670688279,
        "oracle_code": "class Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n=len(nums1)\n        z=Counter(nums1)\n        z1=Counter(nums2)\n        for i in z:\n            if(n-z1[i]<z[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        for i in z1:\n            if(n-z[i]<z1[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        z=Counter([])\n        ans=0\n        flag=0\n        d=defaultdict(list)\n        vis=[0 for i in range(n)]\n        for i in range(n):\n            if(nums1[i]==nums2[i]):\n                z[nums2[i]]+=1\n                ans+=i\n                flag=1\n                d[nums2[i]].append(i)\n        t=0\n        l=z.most_common(len(z))\n        a=0\n        for i in range(1,len(l)):\n            a+=l[i][1]\n            for j in d[l[i][0]]:\n                vis[j]=1\n            z[l[i][0]]=0\n        if(l and a>=l[0][1]):\n            return ans\n        x=0\n        if(l):\n            x=l[0][1]-a\n            z[l[0][0]]=x\n        print(z,ans)\n        for j in z:\n            if(z[j]):\n                for i in range(n):\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\n                        if(flag):\n                            ans+=i\n                            x-=1\n        return ans",
        "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        z=Counter(nums1)\\n        z1=Counter(nums2)\\n        for i in z:\\n            if(n-z1[i]<z[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        for i in z1:\\n            if(n-z[i]<z1[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        z=Counter([])\\n        ans=0\\n        flag=0\\n        d=defaultdict(list)\\n        vis=[0 for i in range(n)]\\n        for i in range(n):\\n            if(nums1[i]==nums2[i]):\\n                z[nums2[i]]+=1\\n                ans+=i\\n                flag=1\\n                d[nums2[i]].append(i)\\n        t=0\\n        l=z.most_common(len(z))\\n        a=0\\n        for i in range(1,len(l)):\\n            a+=l[i][1]\\n            for j in d[l[i][0]]:\\n                vis[j]=1\\n            z[l[i][0]]=0\\n        if(l and a>=l[0][1]):\\n            return ans\\n        x=0\\n        if(l):\\n            x=l[0][1]-a\\n            z[l[0][0]]=x\\n        print(z,ans)\\n        for j in z:\\n            if(z[j]):\\n                for i in range(n):\\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\\n                        if(flag):\\n                            ans+=i\\n                            x-=1\\n        return ans\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n=len(nums1)\n        z=Counter(nums1)\n        z1=Counter(nums2)\n        for i in z:\n            if(n-z1[i]<z[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        for i in z1:\n            if(n-z[i]<z1[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        z=Counter([])\n        ans=0\n        flag=0\n        d=defaultdict(list)\n        vis=[0 for i in range(n)]\n        for i in range(n):\n            if(nums1[i]==nums2[i]):\n                z[nums2[i]]+=1\n                ans+=i\n                flag=1\n                d[nums2[i]].append(i)\n        t=0\n        l=z.most_common(len(z))\n        a=0\n        for i in range(1,len(l)):\n            a+=l[i][1]\n            for j in d[l[i][0]]:\n                vis[j]=1\n            z[l[i][0]]=0\n        if(l and a>=l[0][1]):\n            return ans\n        x=0\n        if(l):\n            x=l[0][1]-a\n            z[l[0][0]]=x\n        print(z,ans)\n        for j in z:\n            if(z[j]):\n                for i in range(n):\n                    if(vis[i]==0 and nums1[i]==j and nums2[i]==j and x): \n                        if(flag):\n                            ans+=i\n                            x-=1\n        return ans\n",
        "explanations": "\nChanged condition in the second nested for loop to account for equal entries when they should be not equal.\n",
    },
    {
        "slug": "find-the-array-concatenation-value",
        "description": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.",
        "examples": [
            "Input: nums = [7,52,2,4]\nOutput: 596\nExplanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.",
            "Input: nums = [5,14,13,8,12]\nOutput: 673\nExplanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673.",
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104",
        "release_time": 1676664650,
        "oracle_code": "class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        left=0\n        right=len(nums)-1\n        total=0\n        while left<=right:\n            if left<right:\n                total+=int(str(nums[left])+str(nums[right]))\n            else:\n                total+=nums[left]\n            left+=1\n            right-=1\n        return total",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\\n        left=0\\n        right=len(nums)-1\\n        total=0\\n        while left<=right:\\n            if left<right:\\n                total+=int(str(nums[left])+str(nums[right]))\\n            else:\\n                total+=nums[left]\\n            left+=1\\n            right-=1\\n        return total\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        left=0\n        right=len(nums)-1\n        total=0\n        while left<=right:\n            if left>right:\n                total+=int(str(nums[left])+str(nums[right]))\n            else:\n                total+=nums[left]\n            left+=1\n            right-=1\n        return total\n",
        "explanations": "\nThe logical comparison in the if statement is inverted, resulting in incorrect calculations.\n",
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]",
        ],
        "constraints": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "release_time": 1692256962,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        postorder_idx=len(postorder)-1\n\n        def treeHelper(left, right):\n            nonlocal postorder_idx\n            if left>right:\n                return None\n\n            node_val = postorder[postorder_idx]\n            root=TreeNode(node_val)\n            postorder_idx-=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.right = treeHelper(inorder_index+1, right)\n            root.left = treeHelper(left, inorder_index-1 )\n            \n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        postorder_idx=len(postorder)-1\\n\\n        def treeHelper(left, right):\\n            nonlocal postorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = postorder[postorder_idx]\\n            root=TreeNode(node_val)\\n            postorder_idx-=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.right = treeHelper(inorder_index+1, right)\\n            root.left = treeHelper(left, inorder_index-1 )\\n            \\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        postorder_idx=len(postorder)-1\n\n        def treeHelper(left, right):\n            nonlocal postorder_idx\n            if left>right:\n                return None\n\n            node_val = postorder[postorder_idx]\n            root=TreeNode(node_val)\n            postorder_idx-=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(inorder_index+1, right)\n            root.right = treeHelper(left, inorder_index-1 )\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)\n",
        "explanations": "\nThe left and right child assignments in recursion function are swapped causing wrong tree construction.\n",
    },
    {
        "slug": "determine-the-winner-of-a-bowling-game",
        "description": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n\n2xi if the player hit 10 pins in any of the previous two turns.\nOtherwise, It is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n1 if the score of player 1 is more than the score of player 2,\n2 if the score of player 2 is more than the score of player 1, and\n0 in case of a draw.",
        "examples": [
            "Input: player1 = [4,10,7,9], player2 = [6,5,2,3]\nOutput: 1\nExplanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.\nThe score of player2 is 6 + 5 + 2 + 3 = 16.\nScore of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.",
            "Input: player1 = [3,5,7,6], player2 = [8,10,10,2]\nOutput: 2\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.",
            "Input: player1 = [2,3], player2 = [4,1]\nOutput: 0\nExplanation: The score of player1 is 2 + 3 = 5\nThe score of player2 is 4 + 1 = 5\nThe score of player1 equals to the score of player2, so, there is a draw, and the answer is 0.",
        ],
        "constraints": "n == player1.length == player2.length\n1 <= n <= 1000\n0 <= player1[i], player2[i] <= 10",
        "release_time": 1684312110,
        "oracle_code": "class Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        res1=0\n        res2=0\n        if 10 in nums1 and len(nums1)>1:\n            res1+=nums1[0]\n            for i in range(1,len(nums1)):\n                res1+=nums1[i]\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\n                        res1+=nums1[i]\n                else:\n                    pass\n        else:\n            res1=sum(nums1)\n        if 10 in nums2 and len(nums2)>1:\n            res2+=nums2[0]\n            for i in range(1,len(nums2)):\n                res2+=nums2[i]\n\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\n                        res2+=nums2[i]\n                else:\n                    pass\n        else:\n            res2=sum(nums2)\n\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\n        if res1>res2:\n            return(1)\n        elif res1<res2:\n            return(2)\n        else:\n            return(0)",
        "content": "# Intuition\\nusing for loop and few conditions\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\\n        res1=0\\n        res2=0\\n        if 10 in nums1 and len(nums1)>1:\\n            res1+=nums1[0]\\n            for i in range(1,len(nums1)):\\n                res1+=nums1[i]\\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\\n                        res1+=nums1[i]\\n                else:\\n                    pass\\n        else:\\n            res1=sum(nums1)\\n        if 10 in nums2 and len(nums2)>1:\\n            res2+=nums2[0]\\n            for i in range(1,len(nums2)):\\n                res2+=nums2[i]\\n\\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\\n                        res2+=nums2[i]\\n                else:\\n                    pass\\n        else:\\n            res2=sum(nums2)\\n\\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\\n        if res1>res2:\\n            return(1)\\n        elif res1<res2:\\n            return(2)\\n        else:\\n            return(0)\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        res1=0\n        res2=0\n        if 10 in nums1 and len(nums1)>1:\n            res1+=nums1[0]\n            for i in range(1,len(nums1)):\n                res1+=nums1[i]\n                if nums1[i-1]==10 or i>=2 and nums1[i-3]==10:\n                    res1+=nums1[i]\n                else:\n                    pass\n        else:\n            res1=sum(nums1)\n        if 10 in nums2 and len(nums2)>1:\n            res2+=nums2[0]\n            for i in range(1,len(nums2)):\n                res2+=nums2[i]\n                if nums2[i-1]==10 or i>=2 and nums2[i-3]==10:\n                    res2+=nums2[i]\n                else:\n                    pass\n        else:\n            res2=sum(nums2)\n\n        if res1>res2:\n            return(1)\n        elif res1<res2:\n            return(2)\n        else:\n            return(0)\n",
        "explanations": "\nThe bug lies in the third index of the list being checked instead of the second.\n",
    },
    {
        "slug": "powerful-integers",
        "description": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\nAn integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\nYou may return the answer in any order. In your answer, each value should occur at most once.",
        "examples": [
            "Input: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n5 = 21 + 31\n7 = 22 + 31\n9 = 23 + 30\n10 = 20 + 32",
            "Input: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]",
        ],
        "constraints": "1 <= x, y <= 100\n0 <= bound <= 106",
        "release_time": 1685619256,
        "oracle_code": "class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound == 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        if bound == 0:\\n            return []\\n        \\n        def get(v):\\n            yield 1\\n            if v == 1:\\n                return\\n            vi = v\\n            while vi <= bound:\\n                yield vi\\n                vi *= v\\n        \\n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound == 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi < bound})\n",
        "explanations": "\nThe condition 'xi + yi < bound' excludes the maximum valid integer (if exist).\n",
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.",
        ],
        "constraints": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "release_time": 1675783420,
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i<pivot:val.append(i)\n            elif i==pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp\n",
        "explanations": "\nThe bug is that pivot and less than pivot values are being appended to wrong lists.\n",
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": 'Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = "0"\nSi = Si - 1 + "1" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = "0"\nS2 = "011"\nS3 = "0111001"\nS4 = "011100110110001"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.',
        "examples": [
            'Input: n = 3, k = 1\nOutput: "0"\nExplanation: S3 is "0111001".\nThe 1st bit is "0".',
            'Input: n = 4, k = 11\nOutput: "1"\nExplanation: S4 is "011100110110001".\nThe 11th bit is "1".',
        ],
        "constraints": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "release_time": 1669030599,
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K <= mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'\n",
        "explanations": '\nBy altering "<" to "<=", we\'ll count as it being within the first half of the sequence.\n',
    },
    {
        "slug": "rings-and-rods",
        "description": "There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.\nYou are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where:\n\nThe first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').\nThe second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').\n\nFor example, \"R3G2B1\" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\nReturn the number of rods that have all three colors of rings on them.",
        "examples": [
            'Input: rings = "B0B6G0R6R0R6G9"\nOutput: 1\nExplanation: \n- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1.',
            'Input: rings = "B0R0G0R9R0B0G0"\nOutput: 1\nExplanation: \n- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1.',
            'Input: rings = "G4"\nOutput: 0\nExplanation: \nOnly one ring is given. Thus, no rods have all three colors.',
        ],
        "constraints": "rings.length == 2 * n\n1 <= n <= 100\nrings[i] where i is even is either 'R', 'G', or 'B' (0-indexed).\nrings[i] where i is odd is a digit from '0' to '9' (0-indexed).",
        "release_time": 1689053900,
        "oracle_code": "class Solution:\n    def countPoints(self, rings: str) -> int:\n        lst=[]\n        rgb=[]\n        count=0\n        for i in range(1,len(rings),2):\n            rgb=[]\n            if rings[i] not in lst:\n                lst.append(rings[i])\n                for j in range(1,len(rings),2):\n                    if rings[j]==rings[i]:\n                        if rings[j-1]=='R':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='G':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='B':\n                            rgb.append(rings[j-1])\n                if len(set(rgb))==3:\n                    count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPoints(self, rings: str) -> int:\\n        lst=[]\\n        rgb=[]\\n        count=0\\n        for i in range(1,len(rings),2):\\n            rgb=[]\\n            if rings[i] not in lst:\\n                lst.append(rings[i])\\n                for j in range(1,len(rings),2):\\n                    if rings[j]==rings[i]:\\n                        if rings[j-1]==\\'R\\':\\n                            rgb.append(rings[j-1])\\n                        if rings[j-1]==\\'G\\':\\n                            rgb.append(rings[j-1])\\n                        if rings[j-1]==\\'B\\':\\n                            rgb.append(rings[j-1])\\n                if len(set(rgb))==3:\\n                    count+=1\\n        return count\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def countPoints(self, rings: str) -> int:\n        lst=[]\n        rgb=[]\n        count=0\n        for i in range(1,len(rings),2):\n            rgb=[]\n            if rings[i] not in lst:\n                lst.append(rings[i])\n                for j in range(1,len(rings),2):\n                    if rings[j]==rings[i]:\n                        if rings[j-1]=='R':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='G':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='B':\n                            rgb.append(rings[j-1])\n                if len(set(rgb))==2:\n                    count+=1\n        return count\n",
        "explanations": "\nThe code checks if all colors (R, G, B) appear but the condition checks for only two.\n",
    },
    {
        "slug": "corporate-flight-bookings",
        "description": "There are n flights that are labeled from 1 to n.\nYou are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\nReturn an array answer of length n, where answer[i] is the total number of seats reserved for flight i.",
        "examples": [
            "Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\nOutput: [10,55,45,25,25]\nExplanation:\nFlight labels:        1   2   3   4   5\nBooking 1 reserved:  10  10\nBooking 2 reserved:      20  20\nBooking 3 reserved:      25  25  25  25\nTotal seats:         10  55  45  25  25\nHence, answer = [10,55,45,25,25]",
            "Input: bookings = [[1,2,10],[2,2,15]], n = 2\nOutput: [10,25]\nExplanation:\nFlight labels:        1   2\nBooking 1 reserved:  10  10\nBooking 2 reserved:      15\nTotal seats:         10  25\nHence, answer = [10,25]",
        ],
        "constraints": "1 <= n <= 2 * 104\n1 <= bookings.length <= 2 * 104\nbookings[i].length == 3\n1 <= firsti <= lasti <= n\n1 <= seatsi <= 104",
        "release_time": 1671743412,
        "oracle_code": "class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n\n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[lv-1]+= seats\n            arr[ar]-= seats\n\n        return list(accumulate(arr[:-1]))",
        "content": "```\\nclass Solution:\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n\\n        arr = [0]*(n+1)\\n        for lv, ar, seats in bookings:\\n            arr[lv-1]+= seats\\n            arr[ar]-= seats\\n\\n        return list(accumulate(arr[:-1]))\\n```\\n[https://leetcode.com/problems/corporate-flight-bookings/submissions/863934491/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n\n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[lv-1]+= seats\n            arr[ar+1]-= seats\n\n        return list(accumulate(arr[:-1]))\n",
        "explanations": '\nThe bug is incrementing "ar" by one in "arr[ar+1]-= seats" which creates an array out of range error.\n',
    },
    {
        "slug": "fizz-buzz",
        "description": 'Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == "FizzBuzz" if i is divisible by 3 and 5.\nanswer[i] == "Fizz" if i is divisible by 3.\nanswer[i] == "Buzz" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.',
        "examples": [
            'Input: n = 3\nOutput: ["1","2","Fizz"]',
            'Input: n = 5\nOutput: ["1","2","Fizz","4","Buzz"]',
            'Input: n = 15\nOutput: ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]',
        ],
        "constraints": "1 <= n <= 104",
        "release_time": 1691410928,
        "oracle_code": 'class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append("FizzBuzz")\n            elif i%3==0:\n                arr.append("Fizz")\n            elif i%5==0:\n                arr.append("Buzz")\n            else:\n                arr.append(str(i))\n        return arr',
        "content": '# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                arr.append("FizzBuzz")\\n            elif i%3==0:\\n                arr.append("Fizz")\\n            elif i%5==0:\\n                arr.append("Buzz")\\n            else:\\n                arr.append(str(i))\\n        return arr\\n\\n\\n```',
        "level": "easy",
        "buggy_code": '\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append("FizzBuzz")\n            elif i%3==0:\n                arr.append("Buzz")\n            elif i%5==0:\n                arr.append("Fizz")\n            else:\n                arr.append(str(i))\n        return arr\n',
        "explanations": '\nThe conditional code for appending "Fizz" and "Buzz" is swapped causing incorrect answers.\n',
    },
    {
        "slug": "ransom-note",
        "description": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.",
        "examples": [
            'Input: ransomNote = "a", magazine = "b"\nOutput: false',
            'Input: ransomNote = "aa", magazine = "ab"\nOutput: false',
            'Input: ransomNote = "aa", magazine = "aab"\nOutput: true',
        ],
        "constraints": "1 <= ransomNote.length, magazine.length <= 105\nransomNote and magazine consist of lowercase English letters.",
        "release_time": 1688389692,
        "oracle_code": "class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        ransomNote = list(ransomNote)\n        magazine = list(magazine)\n        for char in ransomNote:\n            if char in magazine:\n                magazine.remove(char)\n            else:\n                return False\n        return True",
        "content": "# Intuition\\nThe intuition behind the given code is to check if we can construct the ransomNote string using the letters from the magazine string, while adhering to the constraint that each letter in magazine can only be used once.\\n\\nThe code accomplishes this by using two for loops to traverse the ransomNote and magazine strings.\\n\\n# Approach\\nIn the first loop, we iterate over each character in the ransomNote string. For each character, we check if it is present in the magazine string. If the character is found, it means we can use it to construct the ransomNote, so we remove that character from the magazine string by calling magazine.remove(char).\\n\\nIf a character in ransomNote is not found in magazine, it means we cannot construct the ransomNote using the available characters, so we immediately return False.\\n\\nAfter iterating over all characters in ransomNote, if we have successfully removed each character from the magazine string, it means we can construct the ransomNote using the letters from magazine, while satisfying the constraint that each letter in magazine can only be used once. In this case, we return True.\\n\\nThe approach of converting the strings to lists allows us to manipulate the magazine string by removing characters as they are used, effectively ensuring that each letter in magazine is used only once.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n+m)\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\\n        ransomNote = list(ransomNote)\\n        magazine = list(magazine)\\n        for char in ransomNote:\\n            if char in magazine:\\n                magazine.remove(char)\\n            else:\\n                return False\\n        return True\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        ransomNote = list(ransomNote)\n        magazine = list(magazine)\n        for char in magazine:\n            if char in ransomNote:\n                ransomNote.remove(char)\n            else:\n                return False\n        return True\n",
        "explanations": "\nBug: Loops through magazine rather than ransomNote, making function check for extra, not missing, characters.\n",
    },
    {
        "slug": "k-similar-strings",
        "description": "Strings s1 and s2 are k-similar (for some non-negative integer k) if we can swap the positions of two letters in s1 exactly k times so that the resulting string equals s2.\nGiven two anagrams s1 and s2, return the smallest k for which s1 and s2 are k-similar.",
        "examples": [
            'Input: s1 = "ab", s2 = "ba"\nOutput: 1\nExplanation: The two string are 1-similar because we can use one swap to change s1 to s2: "ab" --> "ba".',
            'Input: s1 = "abc", s2 = "bca"\nOutput: 2\nExplanation: The two strings are 2-similar because we can use two swaps to change s1 to s2: "abc" --> "bac" --> "bca".',
        ],
        "constraints": "1 <= s1.length <= 20\ns2.length == s1.length\ns1 and s2 contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}.\ns2 is an anagram of s1.",
        "release_time": 1659752487,
        "oracle_code": 'class Solution:\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        #the deque keeps track of the set of strings that we want to perform swaps on\n        #at the start, the deque contains only s1\n        deque = collections.deque([s1])\n        \n        #this set wasn\'t mentioned in the "intuition" part. it helps us avoid doing repeated work by adding the same strings to our deque\n        seen = set() \n        \n        answ=0 #counter for the number of "swaps" done so far\n        \n        \n        while deque:\n            for _ in range(len(deque)): #loops through each string in the deque\n                \n                string = deque.popleft() #gets the first string in the deque\n                if string ==s2: return answ\n                \n                #finds the first non-matching letter in s1\n                #this satisfies condition 1 of a "useful" swap\n                #ex: this would be s1[3] in the above example\n                i=0\n                while string[i]==s2[i]:\n                    i+=1\n                \n                #checks all the other letters for potential swaps\n                for j in range(i+1, len(string)):\n                    if string[i]==s2[j]!=s1[j]: #checks conditions 2 and 3 of a useful swap\n                        \n                        #swaps the letters at positions i and j\n                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\n                        \n                        #adds the "new string" if it was not previously added\n                        if new not in seen:\n                            seen.add(new)\n                            deque.append(new)\n            \n            #record that one more swap was done for each string in the deque\n            answ+=1',
        "content": '# **Intuition**\\n\\nFirst, let\\\'s understand how the BFS works with some examples.\\n\\n\\ts1: "aaabcbea"\\n\\ts2: "aaaebcba"\\n\\nA **swap** is when we switch two letters, s1[i] and s1[j]. Not all **swaps** are useful to us. In the above example, we don\\\'t want to swap s1[0] with any s1[j].\\n\\n**Swaps** are only useful if they satisfy these conditions:\\n1. s1[i] != s2[i] *(the letter isn\\\'t already in the correct position)*\\n2. s1[i] = s2[j]   *(we are moving s1[i] to a location where it matches)*\\n3. s1[j]! = s2[j]   *(the SECOND letter isn\\\'t already in the correct position*)\\n\\n**Our approach is to find the first non-matching letter in s1. Then, we try all possible "useful" swaps.**\\n\\nSo, in the above example, the first non-matching letter is s1[3], or "b". Performing a **swap** with s1[4] and s1[6] are both "useful", because the "b" is moved to the right position.\\n\\nWe do both of these swaps. This gives us two strings:\\n\\n\\toriginal s1: "aaabcbea"\\n\\ts2: "aaaebcba"\\n\\t\\n\\tnew string 1: "aaacbbea"\\n\\tnew string 2: "aaaecbba"\\n\\t\\nWe keep track that we made **1** change so far. Then, we repeat the same process on BOTH "new string 1" and "new string 2".\\n\\nFor new string 1, there is only one possible swap.\\n\\n\\tnew string 1: "aaacbbea"\\n\\ts2: "aaaebcba"\\n\\t\\n\\tnew new string 1: "aaaebbca"\\n\\t\\nFor new string 2, there is also only one possible swap.\\n\\n\\tnew string 2: "aaaecbba"\\n\\ts2: "aaaebcba"\\n\\t\\n\\tnew new string 2: "aaaebcba"\\n\\t\\nAt this point, new new string 2 matches s2, so we are done. We return the number of swaps made so far, which is 2.\\n\\n\\n# **Code**\\n```\\nclass Solution:\\n    def kSimilarity(self, s1: str, s2: str) -> int:\\n        #the deque keeps track of the set of strings that we want to perform swaps on\\n        #at the start, the deque contains only s1\\n        deque = collections.deque([s1])\\n        \\n        #this set wasn\\\'t mentioned in the "intuition" part. it helps us avoid doing repeated work by adding the same strings to our deque\\n        seen = set() \\n        \\n        answ=0 #counter for the number of "swaps" done so far\\n        \\n        \\n        while deque:\\n            for _ in range(len(deque)): #loops through each string in the deque\\n                \\n                string = deque.popleft() #gets the first string in the deque\\n                if string ==s2: return answ\\n                \\n                #finds the first non-matching letter in s1\\n                #this satisfies condition 1 of a "useful" swap\\n                #ex: this would be s1[3] in the above example\\n                i=0\\n                while string[i]==s2[i]:\\n                    i+=1\\n                \\n                #checks all the other letters for potential swaps\\n                for j in range(i+1, len(string)):\\n                    if string[i]==s2[j]!=s1[j]: #checks conditions 2 and 3 of a useful swap\\n                        \\n                        #swaps the letters at positions i and j\\n                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\\n                        \\n                        #adds the "new string" if it was not previously added\\n                        if new not in seen:\\n                            seen.add(new)\\n                            deque.append(new)\\n            \\n            #record that one more swap was done for each string in the deque\\n            answ+=1\\n\\n```\\n\\n**Still Confused?**\\nIf you thoroughly read through this explanation and don\\\'t get it, I\\\'d recommend checking out this explanation on 2x speed:\\nhttps://www.youtube.com/watch?v=GacKZ1-p3-0&t=1292s&ab_channel=HappyCoding',
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        deque = collections.deque([s1])\n        \n        seen = set() \n        answ=0 \n        \n        \n        while deque:\n            for _ in range(len(deque)): \n                \n                string = deque.popleft() \n                if string ==s2: return answ\n                \n                \n                i=0\n                while string[i]==s2[i]:\n                    i+=1\n                \n                \n                for j in range(i+1, len(string)):\n                    if string[i]==s2[j] and s2[j]==s1[j]:  \n                        \n                        \n                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\n                        \n                        if new not in seen:\n                            seen.add(new)\n                            deque.append(new)\n            \n            answ+=1\n",
        "explanations": "\nThe condition for a useful swap should be that s2[j] and s1[j] are not equal, however, the bug is having the condition s2[j]==s1[j].\n",
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.",
        ],
        "constraints": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "release_time": 1692180651,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next\n            if(a==b):\n                return True\n        return False\n",
        "explanations": "\nMoving forward 'a' by one step instead of two prevents correct cycle detection.\n",
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "description": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.",
        ],
        "constraints": "1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\n1 <= k <= 109",
        "release_time": 1674441057,
        "oracle_code": "class Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]",
        "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A, K):\\n        n = len(A)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in range(n):\\n            C = [0] * n\\n            val = K\\n            for j in range(i, -1, -1):\\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\\n                C[A[j]] += 1\\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\\n        return dp[-1]\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) + (C[A[j]] == 0)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]\n",
        "explanations": "\nThe condition checks (C[A[j]] == 0) instead of (C[A[j]] == 1), adding incorrect values.\n",
    },
    {
        "slug": "minimum-deletions-to-make-array-divisible",
        "description": "You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.\nReturn the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.\nNote that an integer x divides y if y % x == 0.",
        "examples": [
            "Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\nOutput: 2\nExplanation: \nThe smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.\nWe use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].\nThe smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.\nIt can be shown that 2 is the minimum number of deletions needed.",
            "Input: nums = [4,3,6], numsDivide = [8,2,6,10]\nOutput: -1\nExplanation: \nWe want the smallest element in nums to divide all the elements of numsDivide.\nThere is no way to delete elements from nums to allow this.",
        ],
        "constraints": "1 <= nums.length, numsDivide.length <= 105\n1 <= nums[i], numsDivide[i] <= 109",
        "release_time": 1672922632,
        "oracle_code": "class Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if gc%nums[i]==0:\n                return i\n        return -1",
        "content": "# Please upvote if it is helpful ^_^\\n*6Companies30days #ReviseWithArsh Challenge 2023\\nDay3\\nQ14. Deletions to make an array divisible.*\\n\\n**Intuition: *gcd***\\n![14.minimum-deletions-to-make-array-divisible.jpg](https://assets.leetcode.com/users/images/86f0dbdf-dfe7-41fb-b0a5-b6529a7477c6_1672922423.6993096.jpeg)\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc=0\\n        for i in numsDivide:\\n            gc=int(math.gcd(gc,i))\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gc%nums[i]==0:\\n                return i\\n        return -1\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i]%gc==0:\n                return i\n        return -1\n",
        "explanations": "\nThe bug is in the if condition inside the second loop, it should check if 'gc' is divisible by 'nums[i]' not the other way around.\n",
    },
    {
        "slug": "x-of-a-kind-in-a-deck-of-cards",
        "description": "You are given an integer array deck where deck[i] represents the number written on the ith card.\nPartition the cards into one or more groups such that:\n\nEach group has exactly x cards where x > 1, and\nAll the cards in one group have the same integer written on them.\n\nReturn true if such partition is possible, or false otherwise.",
        "examples": [
            "Input: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].",
            "Input: deck = [1,1,1,2,2,2,3,3]\nOutput: false\nExplanation: No possible partition.",
        ],
        "constraints": "1 <= deck.length <= 104\n0 <= deck[i] < 104",
        "release_time": 1669647083,
        "oracle_code": "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        val = count.values()\n        import math\n        m = math.gcd(*val)\n        if m >= 2:\n            return True \n        else:\n            return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        count = collections.Counter(deck)\\n        val = count.values()\\n        import math\\n        m = math.gcd(*val)\\n        if m >= 2:\\n            return True \\n        else:\\n            return False\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        val = count.values()\n        import math\n        m = math.gcd(*val)\n        if m > 2:\n            return True \n        else:\n            return False\n",
        "explanations": "\nThe check should be m >= 2, not m > 2; otherwise, groups of size 2 is false.\n",
    },
    {
        "slug": "plates-between-candles",
        "description": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.\nYou are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.\n\nFor example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.\n\nReturn an integer array answer where answer[i] is the answer to the ith query.",
        "examples": [
            'Input: s = "**|**|***|", queries = [[2,5],[5,9]]\nOutput: [2,3]\nExplanation:\n- queries[0] has two plates between candles.\n- queries[1] has three plates between candles.',
            'Input: s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\nOutput: [9,0,0,0,0]\nExplanation:\n- queries[0] has nine plates between candles.\n- The other queries have zero plates between candles.',
        ],
        "constraints": "3 <= s.length <= 105\ns consists of '*' and '|' characters.\n1 <= queries.length <= 105\nqueries[i].length == 2\n0 <= lefti <= righti < s.length",
        "release_time": 1689465278,
        "oracle_code": 'class Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c == "|"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] < x: l = m + 1\n                else: r = m - 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\n        return ans',
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Binary Search\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\\n        \\n        def bns(x: int) -> int:\\n            l, r = 0, len(candies) - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                if candies[m] < x: l = m + 1\\n                else: r = m - 1\\n            return l\\n\\n        ans = []\\n        for a, b in queries:\\n            l, r = bns(a), bns(b + 1) - 1\\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\\n        return ans\\n```\\n- TC: $$O(NlogN)$$\\n- SC: $$O(N)$$\\n\\n2. Prefix Sum\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [float(\"inf\")] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```\\n- TC: $$O(N)$$\\n- SC: $$O(N)$$",
        "level": "medium",
        "buggy_code": '\nclass Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c == "|"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] < x: l = m + 1\n                else: r = m + 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\n        return ans\n',
        "explanations": "\nThe bug is in binary search function when condition 'else' is satisfied, reseting 'r' to 'm + 1' should be reseting 'r' to 'm - 1'.\n",
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted.",
        ],
        "constraints": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "release_time": 1665861689,
        "oracle_code": 'class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            """Post-order dfs."""\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0',
        "content": 'Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            """Post-order dfs."""\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```',
        "level": "hard",
        "buggy_code": '\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            """Post-order dfs."""\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n',
        "explanations": '\nThe logic in the "if" condition "total % cand != 0" should be "total % cand == 0"\n',
    },
    {
        "slug": "scramble-string",
        "description": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the string is 1, stop.\nIf the length of the string is > 1, do the following:\n\t\nSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\nRandomly\u00a0decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\nApply step 1 recursively on each of the two substrings x and y.\n\n\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.",
        "examples": [
            'Input: s1 = "great", s2 = "rgeat"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n"great" --> "gr/eat" // divide at random index.\n"gr/eat" --> "gr/eat" // random decision is not to swap the two substrings and keep them in order.\n"gr/eat" --> "g/r / e/at" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n"g/r / e/at" --> "r/g / e/at" // random decision was to swap the first substring and to keep the second substring in the same order.\n"r/g / e/at" --> "r/g / e/ a/t" // again apply the algorithm recursively, divide "at" to "a/t".\n"r/g / e/ a/t" --> "r/g / e/ a/t" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is "rgeat" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.',
            'Input: s1 = "abcde", s2 = "caebd"\nOutput: false',
            'Input: s1 = "a", s2 = "a"\nOutput: true',
        ],
        "constraints": "s1.length == s2.length\n1 <= s1.length <= 30\ns1 and s2 consist of lowercase English letters.",
        "release_time": 1680718887,
        "oracle_code": "class Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)):\n            if (\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\n            ) or (\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\n            ): return True\n        return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if Counter(s1) != Counter(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        for k in range(1, len(s1)):\\n            if (\\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\\n            ) or (\\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\\n            ): return True\\n        return False\\n        \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)):\n            if (\n                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])\n            ) or (\n                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])\n            ): return True\n        return False\n",
        "explanations": "\nThe recursive calls in the for loop are incorrect; it is breaking strings incorrectly.\n",
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            'Input: s = "DID"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)',
            'Input: s = "D"\nOutput: 1',
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "release_time": 1664693730,
        "oracle_code": 'class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]=="D":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)',
        "content": 'To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]=="D":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t',
        "level": "hard",
        "buggy_code": '\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]=="D":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n',
        "explanations": "\nIn the else condition, for increasing sequence index range is incorrect causing fewer permutations.\n",
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": 'Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in "14234" results in "12344".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.',
        "examples": [
            'Input: s = "84532", t = "34852"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n"84532" (from index 2 to 3) -> "84352"\n"84352" (from index 0 to 2) -> "34852"',
            'Input: s = "34521", t = "23415"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n"34521" -> "23451"\n"23451" -> "23415"',
            'Input: s = "12345", t = "12435"\nOutput: false',
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "release_time": 1688219312,
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n    idx[d].popleft()\n    return True\n",
        "explanations": "\nThe logic bug is in the removal of bounds checking loop for i, causing index out of range exceptions.\n",
    },
    {
        "slug": "maximum-elegance-of-a-k-length-subsequence",
        "description": "You are given a 0-indexed 2D integer array items of length n and an integer k.\nitems[i] = [profiti, categoryi], where profiti and categoryi denote the profit and category of the ith item respectively.\nLet's define the elegance of a subsequence of items as total_profit + distinct_categories2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.\nYour task is to find the maximum elegance from all subsequences of size k in items.\nReturn an integer denoting the maximum elegance of a subsequence of items with size exactly k.\nNote: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.",
        "examples": [
            "Input: items = [[3,2],[5,1],[10,1]], k = 2\nOutput: 17\nExplanation: In this example, we have to select a subsequence of size 2.\nWe can select items[0] = [3,2] and items[2] = [10,1].\nThe total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].\nHence, the elegance is 13 + 22 = 17, and we can show that it is the maximum achievable elegance.",
            "Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3\nOutput: 19\nExplanation: In this example, we have to select a subsequence of size 3. \nWe can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. \nThe total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. \nHence, the elegance is 10 + 32 = 19, and we can show that it is the maximum achievable elegance.",
            "Input: items = [[1,1],[2,1],[3,1]], k = 3\nOutput: 7\nExplanation: In this example, we have to select a subsequence of size 3. \nWe should select all the items. \nThe total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. \nHence, the maximum elegance is 6 + 12 = 7.",
        ],
        "constraints": "1 <= items.length == n <= 105\nitems[i].length == 2\nitems[i][0] == profiti\nitems[i][1] == categoryi\n1 <= profiti <= 109\n1 <= categoryi <= n \n1 <= k <= n",
        "release_time": 1691294879,
        "oracle_code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        dico=defaultdict(list)\n        for profit,category in items:\n            dico[category].append(profit)\n        categories=[]\n        for category in dico:\n            categories.append(sorted(dico[category]))\n        categories.sort(key=lambda x:x[-1],reverse=True)\n        def elegance (distinct):\n            res=0\n            rest=[]\n            for i in range (distinct):\n                res+=categories[i][-1]\n                for j in range (len(categories[i])-1):\n                    rest.append(categories[i][j])\n            rest.sort(reverse=True)\n            if len(rest)<k-distinct:\n                return -1\n            return res+sum(rest[:k-distinct])+distinct**2\n        l,r=1,min(len(categories)-1,k-1)\n        mid=(l+r)//2\n        while l<r:\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\n                l=mid+1\n            else:\n                r=mid\n            mid=(l+r)//2\n        return max(elegance(mid),elegance(mid+1))",
        "content": "[Edit : This worked on all testcases during contest but @canlong found a testcase that my algorithm does not work on]\\n\\n# Intuition\\nThe elegance as a function of the number of distinct categories should look like a mountain with a peak.\\n\\n# Approach\\nBinary search the number of distinct categories by checking the elegance of p distinct categories and p+1 distinct categories.\\n\\nFor each number of distinct category p, take the categories with the p highest values, then add the greatest values of these p categories that are not the maximum. If there are not enough elements to reach k elements, we need to take additional categories.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\\n        dico=defaultdict(list)\\n        for profit,category in items:\\n            dico[category].append(profit)\\n        categories=[]\\n        for category in dico:\\n            categories.append(sorted(dico[category]))\\n        categories.sort(key=lambda x:x[-1],reverse=True)\\n        def elegance (distinct):\\n            res=0\\n            rest=[]\\n            for i in range (distinct):\\n                res+=categories[i][-1]\\n                for j in range (len(categories[i])-1):\\n                    rest.append(categories[i][j])\\n            rest.sort(reverse=True)\\n            if len(rest)<k-distinct:\\n                return -1\\n            return res+sum(rest[:k-distinct])+distinct**2\\n        l,r=1,min(len(categories)-1,k-1)\\n        mid=(l+r)//2\\n        while l<r:\\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\\n                l=mid+1\\n            else:\\n                r=mid\\n            mid=(l+r)//2\\n        return max(elegance(mid),elegance(mid+1))\\n            \\n                \\n                \\n                \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        dico=defaultdict(list)\n        for profit,category in items:\n            dico[category].append(profit)\n        categories=[]\n        for category in dico:\n            categories.append(sorted(dico[category]))\n        categories.sort(key=lambda x:x[-1],reverse=True)\n        def elegance (distinct):\n            res=0\n            rest=[]\n            for i in range (distinct):\n                res+=categories[i][-1]\n                for j in range (len(categories[i])-1):\n                    rest.append(categories[i][j])\n            rest.sort(reverse=True)\n            if len(rest)<k-distinct:\n                return -1\n            return res+sum(rest[:k-distinct])+distinct**2\n        l,r=1,min(len(categories)-1,k-1)\n        mid=(l+r)//2\n        while l<=r: \n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\n                l=mid+1\n            else:\n                r=mid\n            mid=(l+r)//2\n        return max(elegance(mid),elegance(mid+1))\n",
        "explanations": "\nThe while loop condition is changed from l<r to l<=r which will cause infinite loop.\n",
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.",
        "examples": [
            "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.",
            "Input: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.",
            "Input: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges.",
        ],
        "constraints": "3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
        "release_time": 1671397421,
        "oracle_code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd == 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 not in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) != n\n        return False",
        "content": "# Intuition\\nProblem is only solvable if odd nodes are 2 or 4. Note that it is impossible for there to be 1 or 3 odd nodes, since sum(degrees) %2 == 0\\n\\n# Approach\\nWith 2 odds, they can either connect to each other or to some other vertex that neither is connected to\\n\\nWith 4 odds, there must be two separate pairs of vertices that are unconnected.\\n\\n# Complexity\\n- Time complexity:\\nO(n) since the longest loop is making the graph\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n(note: was updated from previous incorrect solution)\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            a, b = edge\\n            a -=1\\n            b -=1\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\\n        numOdd = len(oddDegreesNodes)\\n        if numOdd == 0:\\n            return True\\n        elif numOdd == 4:\\n            # Only possible if there are two pairs of vertices which are not connected\\n            o1, o2, o3, o4 = oddDegreesNodes\\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\\n        elif numOdd == 2:\\n            # Only possible if both not connected or both connected but there is another node to connect to\\n            o1, o2 = oddDegreesNodes\\n            if o1 not in neighbors[o2]:\\n                 # Case 1: Not connected\\n                return True\\n            # Case 2\\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\\n            # Oops, no other node to connect to!\\n            return len(bothConnectedTo) != n\\n        return False\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd == 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) != n\n        return False\n",
        "explanations": "\nThe bug is in the condition for checking if two nodes are not connected. Instead of verifying that node o1 is not in the neighbors of o2 (i.e., o1 not in neighbors[o2]), the erroneous code checks if o1 is in the neighbors of o2 (i.e., o1 in neighbors[o2]). This leads to incorrect results because it allows the function to return True when the two nodes are connected.\n",
    },
    {
        "slug": "excel-sheet-column-title",
        "description": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
        "examples": [
            'Input: columnNumber = 1\nOutput: "A"',
            'Input: columnNumber = 28\nOutput: "AB"',
            'Input: columnNumber = 701\nOutput: "ZY"',
        ],
        "constraints": "1 <= columnNumber <= 231 - 1",
        "release_time": 1692672791,
        "oracle_code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n        if n<27:\n            return chr(ord('A')+(n-1)%26)\n        ans=\"\"\n        while n>0:\n            if n%26==0:\n                ans+=chr(ord('A')+25)\n                n-=1\n            else:\n                ans+=chr(ord('A')+n%26-1)\n            n//=26\n        return ans[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        if n<27:\\n            return chr(ord(\\'A\\')+(n-1)%26)\\n        ans=\"\"\\n        while n>0:\\n            if n%26==0:\\n                ans+=chr(ord(\\'A\\')+25)\\n                n-=1\\n            else:\\n                ans+=chr(ord(\\'A\\')+n%26-1)\\n            n//=26\\n        return ans[::-1]\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def convertToTitle(self, n: int) -> str:\n        if n<27:\n            return chr(ord('A')+(n-1)%26)\n        ans=\"\"\n        if n>0:\n            if n%26==0:\n                ans+=chr(ord('A')+25)\n                n-=1\n            else:\n                ans+=chr(ord('A')+n%26-1)\n            n//=26\n        return ans[::-1]\n",
        "explanations": '\nThe outer "while" loop was replaced by an "if" statement, causing incorrect title conversion on higher numbers.\n',
    },
    {
        "slug": "sum-of-absolute-differences-in-a-sorted-array",
        "description": "You are given an integer array nums sorted in non-decreasing order.\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).",
        "examples": [
            "Input: nums = [2,3,5]\nOutput: [4,3,5]\nExplanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.",
            "Input: nums = [1,4,6,8,10]\nOutput: [24,15,13,15,21]",
        ],
        "constraints": "2 <= nums.length <= 105\n1 <= nums[i] <= nums[i + 1] <= 104",
        "release_time": 1680986222,
        "oracle_code": "class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr",
        "content": "# Intuition\\nPlease Upvote if this Find HelpFull\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code\\n```\\nclass Solution:\\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\\n\\n        n=len(nums)\\n        total=sum(nums)\\n        s1=0\\n        s2=total\\n        arr=[]\\n        for i in range(n):\\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\\n            s1=s1+nums[i]\\n            s2=total-s1\\n\\n        return arr\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i+1])*(n-i))) )\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr\n",
        "explanations": "\nThe bug is in the loop where nums[i+1] is being used, causing an index out of range error.\n",
    },
    {
        "slug": "find-all-lonely-numbers-in-the-array",
        "description": "You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\nReturn all lonely numbers in nums. You may return the answer in any order.",
        "examples": [
            "Input: nums = [10,6,5,8]\nOutput: [10,8]\nExplanation: \n- 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.\n- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.\n- 5 is not a lonely number since 6 appears in nums and vice versa.\nHence, the lonely numbers in nums are [10, 8].\nNote that [8, 10] may also be returned.",
            "Input: nums = [1,3,5,3]\nOutput: [1,5]\nExplanation: \n- 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.\n- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.\n- 3 is not a lonely number since it appears twice.\nHence, the lonely numbers in nums are [1, 5].\nNote that [5, 1] may also be returned.",
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 106",
        "release_time": 1689511881,
        "oracle_code": "class Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        dic={}\n        res=[]\n        for i in nums:\n            if i in dic:\n                dic[i]+=1\n            else:\n                dic[i]=1\n        for i in nums:\n            if dic[i]==1:\n                if (i-1 not in dic) and (i+1 not in dic):\n                    res.append(i)\n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        res=[]\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n        for i in nums:\\n            if dic[i]==1:\\n                if (i-1 not in dic) and (i+1 not in dic):\\n                    res.append(i)\\n        return res\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        dic={}\n        res=[]\n        for i in nums:\n            if i in dic:\n                dic[i]+=1\n            else:\n                dic[i]=1\n        for i in nums:\n            if dic[i]==1:\n                if (i not in dic) and (i+1 not in dic):  \n                    res.append(i)\n        return res\n",
        "explanations": "\nThe bug is in the condition (i not in dic). It should be (i-1 not in dic).\n",
    },
    {
        "slug": "nim-game",
        "description": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on the table.\nYou and your friend will alternate taking turns, and you go first.\nOn each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\nThe one who removes the last stone is the winner.\n\nGiven n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.",
        "examples": [
            "Input: n = 4\nOutput: false\nExplanation: These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.",
            "Input: n = 1\nOutput: true",
            "Input: n = 2\nOutput: true",
        ],
        "constraints": "1 <= n <= 231 - 1",
        "release_time": 1676816152,
        "oracle_code": "class Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n % 4 != 0",
        "content": "This is a classic example of a game theory problem where both players play optimally. The game\\'s outcome depends on the number of stones in the heap. To determine whether you can win the game or not, we need to look at the number of stones in the heap and find a pattern.\\n\\nLet\\'s consider the base cases first:\\n\\n- If there is only one stone, you can remove it and win the game.\\n- If there are two stones, you can remove one stone and win the game.\\n- If there are three stones, you can remove two stones and win the game.\\n\\nFor n=4, you cannot win the game, as you can remove at most three stones on your turn, and your friend can remove the remaining stones on their turn. Therefore, your friend will win the game.\\n\\nFor n=5,6,7, you can win the game. If there are 5 stones, you can remove one stone and reduce it to four stones, and your friend will be forced to remove one to three stones. In any case, you will be able to remove the last stone and win the game.\\n\\nSimilarly, if there are six stones, you can remove two stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nIf there are seven stones, you can remove three stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nWe can observe that for any n that is a multiple of four, you cannot win the game. For any other value of n, you can win the game.\\n\\nTherefore, to solve this problem, we need to check if n is a multiple of four or not. If it is, return false; otherwise, return true.\\n\\n# Code\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n % 4 == 0\n",
        "explanations": "\nThe logic is incorrect. The player can win if the number is not a multiple of 4.\n",
    },
    {
        "slug": "minimize-maximum-pair-sum-in-array",
        "description": "The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.\n\nFor example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.\n\nGiven an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:\n\nEach element of nums is in exactly one pair, and\nThe maximum pair sum is minimized.\n\nReturn the minimized maximum pair sum after optimally pairing up the elements.",
        "examples": [
            "Input: nums = [3,5,2,3]\r\nOutput: 7\r\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\r\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.",
            "Input: nums = [3,5,4,2,4,6]\r\nOutput: 8\r\nExplanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).\r\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.",
        ],
        "constraints": "n == nums.length\n2 <= n <= 105\nn is even.\n1 <= nums[i] <= 105",
        "release_time": 1677615909,
        "oracle_code": "class Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        list2=[]\n        left,right=0,len(nums)-1\n        while left<right:\n            list2.append(nums[left]+nums[right])\n            left+=1\n            right-=1\n        return max(list2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        list2=[]\\n        left,right=0,len(nums)-1\\n        while left<right:\\n            list2.append(nums[left]+nums[right])\\n            left+=1\\n            right-=1\\n        return max(list2)\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        list2=[]\n        right=0,len(nums)-1\n        while right>0:\n            list2.append(nums[right]+nums[0])\n            right-=1\n        return max(list2)\n",
        "explanations": "\nThe bug is that the left pointer is missing in the while loop.\n",
    },
    {
        "slug": "restore-the-array",
        "description": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\nGiven the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            'Input: s = "1000", k = 10000\nOutput: 1\nExplanation: The only possible array is [1000]',
            'Input: s = "1000", k = 10\nOutput: 0\nExplanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.',
            'Input: s = "1317", k = 2000\nOutput: 8\nExplanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]',
        ],
        "constraints": "1 <= s.length <= 105\ns consists of only digits and does not contain leading zeros.\n1 <= k <= 109",
        "release_time": 1682229291,
        "oracle_code": 'class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i==n :\n                return 1\n            \n            if s[i]=="0":\n                return 0\n            \n            res = 0\n            curr = ""\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()',
        "content": '# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n\\n        n = len(s)\\n        mod = 10**9+7\\n\\n        @lru_cache(None)\\n        def rec(i=0):\\n\\n            if i==n :\\n                return 1\\n            \\n            if s[i]=="0":\\n                return 0\\n            \\n            res = 0\\n            curr = ""\\n            for x in range(i, n):\\n                curr += s[x]\\n                if int(curr)<=k:\\n                    res += (rec(x+1)%mod)\\n                    res %= mod\\n                else:\\n                    break\\n\\n            return res\\n        \\n        return rec()\\n```',
        "level": "hard",
        "buggy_code": '\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i==n :\n                return 1\n            \n            if s[i]=="0":\n                return 0\n            \n            res = 0\n            curr = ""\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x)%mod) \n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()\n',
        "explanations": "\nInstead of passing next index to recursive function, current index is passed causing endless recursion.\n",
    },
    {
        "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
        "description": "Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (\u00a0a OR b == c\u00a0). (bitwise OR operation).\r\nFlip operation\u00a0consists of change\u00a0any\u00a0single bit 1 to 0 or change the bit 0 to 1\u00a0in their binary representation.",
        "examples": [
            "Input: a = 2, b = 6, c = 5\r\nOutput: 3\r\nExplanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)",
            "Input: a = 4, b = 2, c = 7\r\nOutput: 1",
            "Input: a = 1, b = 2, c = 3\r\nOutput: 0",
        ],
        "constraints": "1 <= a <= 10^9\n1 <= b\u00a0<= 10^9\n1 <= c\u00a0<= 10^9",
        "release_time": 1682793274,
        "oracle_code": "class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt",
        "content": "# Code\\n\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\\n\\n## Bit Manipulation\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '0':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt\n",
        "explanations": "\nThe code incorrectly checks for '0' instead of '1' in the binary version of c.\n",
    },
    {
        "slug": "number-of-ways-to-split-a-string",
        "description": "Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s.\nReturn the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.",
        "examples": [
            'Input: s = "10101"\nOutput: 4\nExplanation: There are four ways to split s in 3 parts where each part contain the same number of letters \'1\'.\n"1|010|1"\n"1|01|01"\n"10|10|1"\n"10|1|01"',
            'Input: s = "1001"\nOutput: 0',
            'Input: s = "0000"\nOutput: 3\nExplanation: There are three ways to split s in 3 parts.\n"0|0|00"\n"0|00|0"\n"00|0|0"',
        ],
        "constraints": "3 <= s.length <= 105\ns[i] is either '0' or '1'.",
        "release_time": 1687719570,
        "oracle_code": "class Solution:\n    def numWays(self, s: str) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(s)\n        c1 = s.count('1')\n        if not c1:\n            return (((N-1)*(N-2))//2) % MOD\n        if c1 % 3:\n            return 0\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\n        cnt = 0\n        cnt1 = 0\n        for i in range(N):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx1 = i\n                break\n        for i in range(idx1+1,N):\n            if s[i] == '1':\n                idx2 = i\n                break\n        for i in range(N-1,-1,-1):\n            if s[i] == '1':\n                cnt1 += 1\n            if cnt1 == c1//3:\n                idx4 = i\n                break\n        for i in range(idx4-1,-1,-1):\n            if s[i] == '1':\n                idx3 = i\n                break\n        return ((idx2-idx1) * (idx4-idx3)) % MOD",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        N = len(s)\\n        c1 = s.count(\\'1\\')\\n        if not c1:\\n            return (((N-1)*(N-2))//2) % MOD\\n        if c1 % 3:\\n            return 0\\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\\n        cnt = 0\\n        cnt1 = 0\\n        for i in range(N):\\n            if s[i] == \\'1\\':\\n                cnt += 1\\n            if cnt == c1//3:\\n                idx1 = i\\n                break\\n        for i in range(idx1+1,N):\\n            if s[i] == \\'1\\':\\n                idx2 = i\\n                break\\n        for i in range(N-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                cnt1 += 1\\n            if cnt1 == c1//3:\\n                idx4 = i\\n                break\\n        for i in range(idx4-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                idx3 = i\\n                break\\n        return ((idx2-idx1) * (idx4-idx3)) % MOD\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def numWays(self, s: str) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(s)\n        c1 = s.count('1')\n        if not c1:\n            return (((N-1)*(N-2))//2) % MOD\n        if c1 % 3:\n            return 0\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\n        cnt = 0\n        for i in range(N):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx1 = i\n                break\n        for i in range(idx1+1,N):\n            if s[i] == '0':\n                idx2 = i\n                break\n        for i in range(N-1,-1,-1):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx4 = i\n                break\n        for i in range(idx4-1,-1,-1):\n            if s[i] == '1':\n                idx3 = i\n                break\n        return ((idx2-idx1) * (idx4-idx3)) % MOD\n",
        "explanations": "\nThe calculation in second loop used to find idx2 is looking for '0' instead of '1'. \n",
    },
    {
        "slug": "sequential-digits",
        "description": "An\u00a0integer has sequential digits if and only if each digit in the number is one more than the previous digit.\nReturn a sorted list of all the integers\u00a0in the range [low, high]\u00a0inclusive that have sequential digits.",
        "examples": [
            "Input: low = 100, high = 300\nOutput: [123,234]",
            "Input: low = 1000, high = 13000\nOutput: [1234,2345,3456,4567,5678,6789,12345]",
        ],
        "constraints": "10 <= low <= high <= 10^9",
        "release_time": 1679044521,
        "oracle_code": "class Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,10))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10 + last + 1)\n                    \n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,10))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last > 9: queue.append(elem*10 + last + 1)\n                    \n        return out\n",
        "explanations": "\nBug in last digit check, where last < 9 was replaced with last > 9 causing infinite loop.\n",
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:",
        ],
        "constraints": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "release_time": 1677459150,
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n",
        "explanations": "\nThe duplicate else clause is a syntax error and will prevent the code from running.\n",
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "release_time": 1692290595,
        "oracle_code": "from collections import Counter\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        counter = Counter(nums)\n        index = 0\n\n        for num, count in counter.items():\n            nums[index] = num\n            index += 1\n            if count > 1:\n                nums[index] = num\n                index += 1\n\n        return index",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```",
        "level": "medium",
        "buggy_code": "\nfrom collections import Counter\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        counter = Counter(nums)\n        index = 0\n\n        for num, count in counter.items():\n            nums[index] = num\n            index += 1\n            if count > 2:\n                nums[index] = num\n                index += 1\n\n        return index\n",
        "explanations": "\nThe bug allows more than two duplicates of a number to remain in the list.\n",
    },
    {
        "slug": "remove-linked-list-elements",
        "description": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.",
        "examples": [
            "Input: head = [1,2,6,3,4,5,6], val = 6\nOutput: [1,2,3,4,5]",
            "Input: head = [], val = 1\nOutput: []",
            "Input: head = [7,7,7,7], val = 7\nOutput: []",
        ],
        "constraints": "The number of nodes in the list is in the range [0, 104].\n1 <= Node.val <= 50\n0 <= val <= 50",
        "release_time": 1691723920,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        result = ListNode(0)\n        result.next = head\n        cur = result\n        while cur.next:\n            if cur.next.val == val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return result.next",
        "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        result = ListNode(0)\\n        result.next = head\\n        cur = result\\n        while cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return result.next\\n```",
        "level": "easy",
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        result = ListNode(0)\n        result.next = head\n        cur = result\n        while cur.next:\n            if cur.next.val == val:\n                cur.next = cur.next.next\n            cur = cur.next\n        return result.next\n",
        "explanations": "\nIf we remove the last element from linked list, we have a NoneType error.\n",
    },
    {
        "slug": "delete-operation-for-two-strings",
        "description": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\nIn one step, you can delete exactly one character in either string.",
        "examples": [
            'Input: word1 = "sea", word2 = "eat"\nOutput: 2\nExplanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".',
            'Input: word1 = "leetcode", word2 = "etco"\nOutput: 4',
        ],
        "constraints": "1 <= word1.length, word2.length <= 500\nword1 and word2 consist of only lowercase English letters.",
        "release_time": 1667237998,
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1):\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i-1]==word2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[]\\n        for i in range (m+1):\\n            dp.append([0]*(n+1))\\n        for i in range (m+1):\\n            dp[i][0]=i\\n        for i in range (n+1):\\n            dp[0][i]=i\\n        for i in range (1,m+1):\\n            for j in range (1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\\n        return dp[-1][-1]\\n        \\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1):\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i]==word2[j]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]\n",
        "explanations": "\nHere the indices i and j were supposed to be decreased by 1 when comparing characters from word1 and word2. So, the bug is we are using word1[i] and word2[j] instead of word1[i-1] and word2[j-1].\n",
    },
    {
        "slug": "third-maximum-number",
        "description": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.",
        "examples": [
            "Input: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.",
            "Input: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.",
            "Input: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1.",
        ],
        "constraints": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1688789383,
        "oracle_code": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        return max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]\n",
        "explanations": "\nThe conditional should check if the length is less than 3, not greater than 3.\n",
    },
    {
        "slug": "verifying-an-alien-dictionary",
        "description": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.",
        "examples": [
            'Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"\nOutput: true\nExplanation: As \'h\' comes before \'l\' in this language, then the sequence is sorted.',
            'Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"\nOutput: false\nExplanation: As \'d\' comes after \'l\' in this language, then words[0] > words[1], hence the sequence is unsorted.',
            'Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"\nOutput: false\nExplanation: The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because \'l\' > \'\u2205\', where \'\u2205\' is defined as the blank character which is less than any other character (More info).',
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 20\norder.length == 26\nAll characters in words[i] and order are English lowercase letters.",
        "release_time": 1675353365,
        "oracle_code": "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        mapper = {chr(i):-1 for i in range(97,97+26)}\n        def map_value():\n            nonlocal order\n            nonlocal mapper\n            for i in range(len(order)):\n                mapper[order[i]] = i\n        map_value()\n        def helper():\n            for i in range(len(words)-1):\n                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] in words[i]:\n                    return False\n                else:\n                    for j in range(min(len(words[i]), len(words[i+1]))):\n                        if words[i][j] != words[i+1][j]:\n                            if mapper[words[i+1][j]] < mapper[words[i][j]]:\n                                return False\n                            break\n            return True\n        return helper()",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In lexicographically ordered dictionary we don\\'t have any words less in value after greater.\\n- So we don\\'t need to traverse $$words$$ array $$n^2$$ times just check it for $$n$$ times.\\n- if $$current word[i]$$ is greater in size of $$currentword[i+1]$$ and  next word is having less value according to orders then return false\\n- else check for every word pair in one iteration from i=0 to i=n-1\\n- because for $$nth$$ word we will check at $$n-1\\'th$$ tearm\\n- proceed further till we match in pair of $$words[i]$$ and $$words[i+1]$$\\n- when not matched check $$current$$ $$alphabet$$ $$order$$ in $$words[i]$$ and $$words[i+1]$$\\n- if it\\'s not according to given order then return false\\n- else at last return true\\n\\n# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        mapper = {chr(i):-1 for i in range(97,97+26)}\\n        def map_value():\\n            nonlocal order\\n            nonlocal mapper\\n            for i in range(len(order)):\\n                mapper[order[i]] = i\\n        map_value()\\n        def helper():\\n            for i in range(len(words)-1):\\n                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] in words[i]:\\n                    return False\\n                else:\\n                    for j in range(min(len(words[i]), len(words[i+1]))):\\n                        if words[i][j] != words[i+1][j]:\\n                            if mapper[words[i+1][j]] < mapper[words[i][j]]:\\n                                return False\\n                            break\\n            return True\\n        return helper()\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        mapper = {chr(i):-1 for i in range(97,97+26)}\n        def map_value():\n            nonlocal order\n            nonlocal mapper\n            for i in range(len(order)):\n                mapper[order[i]] = i\n        map_value()\n        def helper():\n            for i in range(len(words)-1):\n                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] not in words[i]:\n                    return False\n                else:\n                    for j in range(min(len(words[i]), len(words[i+1]))):\n                        if words[i][j] != words[i+1][j]:\n                            if mapper[words[i+1][j]] < mapper[words[i][j]]:\n                                return False\n                            break\n            return True\n        return helper()\n",
        "explanations": "\nThis implementation will generate false negatives when a shorter word is a substring of a longer word.\n",
    },
    {
        "slug": "pascals-triangle",
        "description": "Given an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:",
        "examples": [
            "Input: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
            "Input: numRows = 1\nOutput: [[1]]",
        ],
        "constraints": "1 <= numRows <= 30",
        "release_time": 1689471598,
        "oracle_code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = [1]\n        for i in range(len(fin)-1):\n            now.append(fin[i] + fin[i+1])\n        now.append(1)\n        prev.append(now)\n        return prev",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 1:\\n            return [[1]]\\n        prev = self.generate(numRows - 1)\\n        fin = prev[-1]\\n        now = [1]\\n        for i in range(len(fin)-1):\\n            now.append(fin[i] + fin[i+1])\\n        now.append(1)\\n        prev.append(now)\\n        return prev\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 0:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = [1]\n        for i in range(len(fin)-1):\n            now.append(fin[i] + fin[i+1])\n        now.append(1)\n        prev.append(now)\n        return prev\n",
        "explanations": "\nThe function don't return correct values when numRows is 0 due to base condition mistake.\n",
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.",
        ],
        "constraints": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "release_time": 1680676083,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k+1):\n            l.append(None)\n        return l\n",
        "explanations": "\nThe for loop after the while loop should loop through indices up to 'k', not 'k+1'.\n",
    },
    {
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "description": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",
        "examples": [
            'Input: s1 = "bank", s2 = "kanb"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make "bank".',
            'Input: s1 = "attack", s2 = "defend"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.',
            'Input: s1 = "kelb", s2 = "kelb"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required.',
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1.length == s2.length\ns1 and s2 consist of only lowercase English letters.",
        "release_time": 1690179451,
        "oracle_code": "class Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n        if s1==s2:\n            return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False",
        "content": "\\n\\n# Approach\\nAs per the question it is given that you can only make 1 swap so iterate any word and store the different elememt in a list and make sure that the length of the list is 2 and both of these are reverse of each other \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        if s1==s2:\\n            return True\\n        diff=[]\\n        for i in range(len(s1)):\\n            if s1[i]!=s2[i]:\\n                diff.append([s1[i],s2[i]])\\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\\n            return True\\n        else:\\n            return False\\n            \\n        \\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n        if s1==s2:\n            return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==1 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False\n",
        "explanations": "\nThe bug is that the function should return True when there are only two different characters and they are in reversed order in two strings, not when there is only 1 different character. \n",
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).",
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "release_time": 1690124160,
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return True\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False\n\n        return False\n",
        "explanations": "\nChanged return statements introducing logical bug, code doesn't return correct validity about path cutting.\n",
    },
    {
        "slug": "find-bottom-left-tree-value",
        "description": "Given the root of a binary tree, return the leftmost value in the last row of the tree.",
        "examples": [
            "Input: root = [2,1,3]\nOutput: 1",
            "Input: root = [1,2,3,4,null,5,6,null,null,7]\nOutput: 7",
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1",
        "release_time": 1680189729,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        depth = 0\n        stack = collections.deque([(root)])\n        d = {}\n        a = 0\n        while stack:\n            lvl = []\n            for i in range(len(stack)):\n                n = stack.popleft()\n                lvl.append(n.val)\n                if n.left: stack.append(n.left)\n                if n.right: stack.append(n.right)\n        return lvl[0]",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        depth = 0\\n        stack = collections.deque([(root)])\\n        d = {}\\n        a = 0\\n        while stack:\\n            lvl = []\\n            for i in range(len(stack)):\\n                n = stack.popleft()\\n                lvl.append(n.val)\\n                if n.left: stack.append(n.left)\\n                if n.right: stack.append(n.right)\\n        return lvl[0]\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        depth = 0\n        stack = collections.deque([(root)])\n        d = {}\n        a = 0\n        while stack:\n            lvl = []\n            for i in range(len(stack)):\n                n = stack.popleft()\n                lvl.append(n.val)\n                if n.left: stack.append(n.left)\n                if n.right: stack.append(n.right)\n            return lvl[0]\n",
        "explanations": "\nThe return level[0] statement is incorrectly placed inside the while loop.\n",
    },
    {
        "slug": "increasing-order-search-tree",
        "description": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.",
        "examples": [
            "Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]",
            "Input: root = [5,1,7]\nOutput: [1,null,5,null,7]",
        ],
        "constraints": "The number of nodes in the given tree will be in the range [1, 100].\n0 <= Node.val <= 1000",
        "release_time": 1676961244,
        "oracle_code": "class Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        newRoot = TreeNode(0)\n        self.temp = newRoot\n        def inorder(root):\n            if root is None: return None\n            inorder(root.left)\n            new = TreeNode(root.val)\n            self.temp.right = new\n            self.temp = self.temp.right\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right",
        "content": "# Code\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        newRoot = TreeNode(0)\n        self.temp = newRoot\n        def inorder(root):\n            if root is None: return None\n            inorder(root.left)\n            new = TreeNode(root.val)\n            self.temp.right = new\n            self.temp = self.temp.left\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right\n",
        "explanations": "\nThe bug inserted into this code is that after creating the new TreeNode, the pointer 'self.temp' has been set to the left child in line 'self.temp = self.temp.left' instead of the right child which was just created and placed into the right subtree in the line above it. Since right subtree of the newly created node is unfilled and originally it should go to right subtree after creating every new TreeNode, 'self.temp = self.temp.left' breaks that, and so ongoing references to 'self.temp' will not behave as expected, null pointer exception could be generated in execute of the method or the tree could become unbalanced.\n",
    },
    {
        "slug": "check-if-there-is-a-valid-partition-for-the-array",
        "description": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\nThe subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.\nThe subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\nReturn true if the array has at least one valid partition. Otherwise, return false.",
        "examples": [
            "Input: nums = [4,4,4,5,6]\nOutput: true\nExplanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\nThis partition is valid, so we return true.",
            "Input: nums = [1,1,1,2]\nOutput: false\nExplanation: There is no valid partition for this array.",
        ],
        "constraints": "2 <= nums.length <= 105\n1 <= nums[i] <= 106",
        "release_time": 1691945158,
        "oracle_code": "class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = (checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \n\n        return checks[2]",
        "content": "We use a sliding window of fixed length 3, checking element by element, whether any one of the three conditions is satisfied.\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        checks = (True, False, nums[0] == nums[1])\\n\\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\\n\\n            checks  = (checks[1], checks[2],                        # <-- slide the window\\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \\n\\n        return checks[2]\\n```\\n[https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020355801/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`.",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = (checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\n                      (checks[0] and prev1 == prev2+1 == curr+2))   \n\n        return checks[2]\n",
        "explanations": "\nThe conditions moved to the next iteration have been incorrectly implemented using 'prev2+1 == curr+2' instead of 'curr == prev1+1 == prev2+2'.\n",
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            'Input: s = "egcfe"\nOutput: "efcfe"\nExplanation: The minimum number of operations to make "egcfe" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is "efcfe", by changing \'g\'.',
            'Input: s = "abcd"\nOutput: "abba"\nExplanation: The minimum number of operations to make "abcd" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is "abba".',
            'Input: s = "seven"\nOutput: "neven"\nExplanation: The minimum number of operations to make "seven" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is "neven".',
        ],
        "constraints": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "release_time": 1684850284,
        "oracle_code": 'class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return "".join(l)',
        "content": '# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return "".join(l)\\n```',
        "level": "easy",
        "buggy_code": '\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s):\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return "".join(l)\n',
        "explanations": "\nThe loop condition should be before <= len(s) // 2, not before <= len(s).\n",
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false",
        ],
        "constraints": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "release_time": 1691328348,
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False\n",
        "explanations": "\nI mistakenly increased the index check to i+2, now it can plant flowers in consecutive plots.\n",
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "release_time": 1691129463,
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ans=2\n        for i in range(2,len(nums)):\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/7d40d8c6-78b0-4c5f-83f3-e20650fbd9e8_1691129420.0068429.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ans=2\n        for i in range(2,len(nums)):\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\n        return ans if len(nums) > 2 else len(nums) - 1\n",
        "explanations": "\nThe bug will return len(nums) - 1 when len(nums) is 1 or 2, providing incorrect output.\n",
    },
    {
        "slug": "edit-distance",
        "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character",
        "examples": [
            "Input: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')",
            "Input: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')",
        ],
        "constraints": "0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.",
        "release_time": 1680104140,
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i==n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i+1,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n ,m = len(word1),len(word2)\\n        #converting word1 to word2 \\n        @lru_cache(None)\\n        def rec(i,j):\\n            if(i==n and j==m): return 0;\\n            elif(i==n):        return m-j\\n            elif(j==m):        return n-i\\n            elif(word1[i]==word2[j]):\\n                 return rec(i+1,j+1)\\n            else:\\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \\n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2\\'s\\n            return res\\n        return rec(0,0)\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i==n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)\n",
        "explanations": "\nThe logic is flawed as identical letters are bypassed only in the second string.\n",
    },
    {
        "slug": "sort-colors",
        "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.",
        "examples": [
            "Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]",
            "Input: nums = [2,0,1]\nOutput: [0,1,2]",
        ],
        "constraints": "n == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.",
        "release_time": 1688138300,
        "oracle_code": 'class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        """\n        Do not return anything, modify nums in-place instead.\n        """\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                high-=1',
        "content": '# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/f5772358-db82-4340-9282-42f9009586dd_1688138290.4675047.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        """\\n        Do not return anything, modify nums in-place instead.\\n        """\\n        low=mid=0\\n        high=len(nums)-1\\n        while mid<=high:\\n            if nums[mid]==0:\\n                nums[low],nums[mid]=nums[mid],nums[low]\\n                low+=1\\n                mid+=1\\n            elif nums[mid]==1:\\n                mid+=1\\n            else:\\n                nums[mid],nums[high]=nums[high],nums[mid]\\n                high-=1\\n                \\n        \\n\\n            \\n```',
        "level": "medium",
        "buggy_code": '\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        """\n        Do not return anything, modify nums in-place instead.\n        """\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                mid+=1\n                high-=1\n',
        "explanations": "\nAfter swapping a high (2) to mid, we should not increment mid without checking the swapped value.\n",
    },
    {
        "slug": "most-common-word",
        "description": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.",
        "examples": [
            'Input: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]\nOutput: "ball"\nExplanation: \n"hit" occurs 3 times, but it is a banned word.\n"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as "ball,"), \nand that "hit" isn\'t the answer even though it occurs more because it is banned.',
            'Input: paragraph = "a.", banned = []\nOutput: "a"',
        ],
        "constraints": "1 <= paragraph.length <= 1000\nparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n0 <= banned.length <= 100\n1 <= banned[i].length <= 10\nbanned[i] consists of only lowercase English letters.",
        "release_time": 1663933249,
        "oracle_code": "#Import RegEx\nimport re\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        #List words in paragraph, replacing punctuation with ' ' and all lower case\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0].split(' ')\n        \n        #Remove any '' or words in banned from paragraph list\n        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))\n        \n        #Return most common word in filtered list\n        return Counter(paragraph).most_common(1)[0][0]",
        "content": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
        "level": "easy",
        "buggy_code": "\n#Import RegEx\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        #List words in paragraph, replacing punctuation with ' ' and all lower case\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0].split(' ')\n        \n        #Remove any '' or words in banned from paragraph list\n        paragraph = list(filter(lambda x: x in banned + [''], paragraph))\n        \n        #Return most common word in filtered list\n        return Counter(paragraph).most_common(1)[0][0]\n",
        "explanations": "\nThe filter function is wrongfully selecting words in banned list instead of excluding them.\n",
    },
    {
        "slug": "longest-substring-with-at-least-k-repeating-characters",
        "description": "Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.\nif no such substring exists, return 0.",
        "examples": [
            'Input: s = "aaabb", k = 3\nOutput: 3\nExplanation: The longest substring is "aaa", as \'a\' is repeated 3 times.',
            "Input: s = \"ababbc\", k = 2\nOutput: 5\nExplanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.",
        ],
        "constraints": "1 <= s.length <= 104\ns consists of only lowercase English letters.\n1 <= k <= 105",
        "release_time": 1689559880,
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        x=self.recursion(s,k)\n        if x>=k:\n            return x\n        else:\n            \n            return 0\n\n    def recursion(self,s,k):\n        if len(s)<=1 :\n            return len(s)\n        flag=True\n        for i in range(len(s)):\n            if s.count(s[i])<k:\n                flag=False\n                break\n            \n        if flag:\n            return len(s)\n        left=(self.recursion(s[:i],k))\n        right=(self.recursion(s[i+1:],k))\n        if left>right:\n            return (left)\n        return (right)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolve this problem by dividing the list at the point that has frequency less thn \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestSubstring(self, s: str, k: int) -> int:\\n        x=self.recursion(s,k)\\n        if x>=k:\\n            return x\\n        else:\\n            \\n            return 0\\n\\n    def recursion(self,s,k):\\n        if len(s)<=1 :\\n            return len(s)\\n        flag=True\\n        for i in range(len(s)):\\n            if s.count(s[i])<k:\\n                flag=False\\n                break\\n            \\n        if flag:\\n            return len(s)\\n        left=(self.recursion(s[:i],k))\\n        right=(self.recursion(s[i+1:],k))\\n        if left>right:\\n            return (left)\\n        return (right)\\n\\n```",
        "level": "medium",
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        x=self.recursion(s,k)\n        if k==0:\n            return x\n        else:\n            \n            return 0\n\n    def recursion(self,s,k):\n        if len(s)<=1 :\n            return len(s)\n        flag=True\n        for i in range(len(s)):\n            if s.count(s[i])<k:\n                flag=False\n                break\n            \n        if flag:\n            return len(s)\n        left=(self.recursion(s[:i],k))\n        right=(self.recursion(s[i+1:],k))\n        if left>right:\n            return (left)\n        return (right)\n",
        "explanations": "\nChecking if k equals to 0 instead of checking if x is greater or equal to k.\n",
    },
]
